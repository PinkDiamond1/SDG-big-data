# Mobility Patterns {#mobility}
Individual mobility analysis represent a key ingredient to understand and timely follow changes in their behavioural patterns. In this book we relie on heavily tested and robust GPS traces preprocessing to measure and quantify individual mobility patterns.

## Individual's selection
Following the preprocessing pipeline description presented in the previous sections of the book, here we introduce an additional step aiming at refinining the pool of individuals analysed. Our intent is to measure mobility patterns only for individuals whose activity level is sufficiently high to ensure a minimum level of representativeness of the data. Individuals with recods over only a small number of days cannot be considered as a complete and correct representation fairly proxying the mobility features of an individual.

To this extent we use the duration of each individuals records, which have been computed during the pipeline run.
The selection imposes two requirements on individuals: i) each individual should be active (i.e. should have at least one stop record) for a minimum number of days during the pre-pandemic period (which is choose to run from the beginning of January 2020 until March 15, 2020; ii) each individual should be active for a minimum fraction of days after the pre-pandemic period until the end of 2020. This selection process is obtained invoking the following python function which returns a list of the users to be included during the analyses.

```{python eval=FALSE}
def get_active_list(durations, country, activity_level):
  '''
  For each country invoke the following function to get a list of all active individuals.
    INPUT: dataframe with precomputed individual stops' durations, country ISO code, minimum activity level required
    OUTPUT: list of active individuals "user_id"
  '''

  # Indonesia experiences a major dropout from the service during January 2020. For this reason, a specific pre-pandemic period was adopted
  if country == 'ID':
      durations_2 = durations.where(col('date_trunc') >= '2020-02-01')
  else:
      durations_2 = durations
  durations_2 = durations_2.where(col('date_trunc') < '2021-01-01')

  active_days = (durations_2
                 .withColumn('pandemic', F.when(col('date_trunc') < '2020-03-15', 'pre').otherwise('post'))
                 .groupby('user_id', 'pandemic')
                 .agg(F.countDistinct('date_trunc').alias('n_days')))
  active_days.cache()

  max_days_pre = (active_days
                  .where(col('pandemic') == 'pre')
                  .agg(F.max('n_days').alias('max_days_pre'))
                  .toPandas().loc[0, 'max_days_pre'])

  max_days_all = (active_days
                  .groupby('user_id')
                  .agg(F.sum('n_days').alias('n_days'))
                  .agg(F.max('n_days').alias('max_days_all'))
                  .toPandas().loc[0, 'max_days_all'])

  active_users = (active_days
                  .groupby('user_id')
                  .pivot('pandemic')
                  .agg(F.first('n_days'))
                  .fillna(0)
                  .withColumn('tot', col('pre')+col('post'))
                  .where(col('pre') >= activity_level*max_days_pre)
                  .where(col('tot') >= activity_level*max_days_all))
  active_days.unpersist()

  return active_users
```

## Measures
```{python eval=FALSE}

```

### Measuring mobility
```{python eval=FALSE}

```

### Measuring change




```{python eval=FALSE}
def google_change_metric(df_original, start_baseline, end_baseline,other_groups=[]):
  '''
  INPUT:  dataframe with (at least) 2 columns named "mean" and "sem"
  OUTPUT: dataframe with the values of the two columns converted to google change metric
  NOTE: Google uses as baseline period the 5-weeks period from Jan 3 to Feb 6
  '''
  df = df_original.copy()

  # compute weekday baseline values
  baseline = df.loc[start_baseline:end_baseline,['mean','sem']+other_groups].copy()
  baseline['weekday'] = list(baseline.index.dayofweek.values)
  baseline = baseline.groupby(['weekday']+other_groups,dropna=False,as_index=False).mean()
  df['weekday'] = list(df.index.dayofweek.values)

  date = df.index.copy()
  df = df.merge(baseline, on=['weekday']+other_groups, how='left', =('', '_baseline'))

  # compute "mean" change with respect to weekday baseline values
  df['mean'] = (df['mean']- df['mean_baseline']) / np.abs(df['mean_baseline'])
  df['sem'] = np.abs(df['sem']/df['mean_baseline'])
  df.index = date

  # return input dataframe with "mean" and "sem" column now expressing the relative change and its error
  return df.drop(['weekday','mean_baseline'],axis=1,errors='ignore')
```
