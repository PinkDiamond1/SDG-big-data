<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 2 GPS | Big Data Analytics</title>
  <meta name="description" content="SDG Bookdown" />
  <meta name="generator" content="bookdown 0.24 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 2 GPS | Big Data Analytics" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="SDG Bookdown" />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 2 GPS | Big Data Analytics" />
  
  <meta name="twitter:description" content="SDG Bookdown" />
  

<meta name="author" content="Chapter 2 GPS | Big Data Analytics Group" />


<meta name="date" content="2021-10-09" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="twitter.html"/>
<script src="libs/header-attrs-2.11/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Big Data Analysis</a></li>

<li class="divider"></li>
<li class="part"><span><b>Introduction</b></span></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a>
<ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#gps-analytics"><i class="fa fa-check"></i><b>1.1</b> <span>GPS Analytics</span></a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#labor-market-analysis-with-twitter-data"><i class="fa fa-check"></i><b>1.2</b> <span>Labor market analysis with Twitter data</span></a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#news-analysis-with-twitter-data"><i class="fa fa-check"></i><b>1.3</b> <span>News analysis with Twitter data</span></a></li>
</ul></li>
<li class="part"><span><b>GPS Analytics</b></span></li>
<li class="chapter" data-level="2" data-path="gps.html"><a href="gps.html"><i class="fa fa-check"></i><b>2</b> GPS</a>
<ul>
<li class="chapter" data-level="2.1" data-path="gps.html"><a href="gps.html#data"><i class="fa fa-check"></i><b>2.1</b> Data</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="gps.html"><a href="gps.html#gps-data"><i class="fa fa-check"></i><b>2.1.1</b> GPS Data</a></li>
<li class="chapter" data-level="2.1.2" data-path="gps.html"><a href="gps.html#wealth-index-data"><i class="fa fa-check"></i><b>2.1.2</b> Wealth Index Data</a></li>
<li class="chapter" data-level="2.1.3" data-path="gps.html"><a href="gps.html#administrative-boundaries-data"><i class="fa fa-check"></i><b>2.1.3</b> Administrative Boundaries Data</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="gps.html"><a href="gps.html#geocode"><i class="fa fa-check"></i><b>2.2</b> Geocode</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="gps.html"><a href="gps.html#efficient-spatial-joining-and-geospatial-indexing"><i class="fa fa-check"></i><b>2.2.1</b> Efficient spatial joining and Geospatial Indexing</a></li>
<li class="chapter" data-level="2.2.2" data-path="gps.html"><a href="gps.html#code"><i class="fa fa-check"></i><b>2.2.2</b> Code</a></li>
<li class="chapter" data-level="2.2.3" data-path="gps.html"><a href="gps.html#initial-coarse-geo-spatial-join-with-shapefiles"><i class="fa fa-check"></i><b>2.2.3</b> Initial coarse geo-spatial join with shapefiles</a></li>
<li class="chapter" data-level="2.2.4" data-path="gps.html"><a href="gps.html#final-exact-join-with-a-subset-of-the-shapefiles"><i class="fa fa-check"></i><b>2.2.4</b> Final exact join with a subset of the shapefiles</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="gps.html"><a href="gps.html#stops"><i class="fa fa-check"></i><b>2.3</b> Finding Stops</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="gps.html"><a href="gps.html#definition"><i class="fa fa-check"></i><b>2.3.1</b> Definition</a></li>
<li class="chapter" data-level="2.3.2" data-path="gps.html"><a href="gps.html#clustering-recurrent-stops"><i class="fa fa-check"></i><b>2.3.2</b> Clustering recurrent stops</a></li>
<li class="chapter" data-level="2.3.3" data-path="gps.html"><a href="gps.html#appending-pings-from-recent-dates"><i class="fa fa-check"></i><b>2.3.3</b> Appending pings from recent dates</a></li>
<li class="chapter" data-level="2.3.4" data-path="gps.html"><a href="gps.html#stops-geocoding"><i class="fa fa-check"></i><b>2.3.4</b> Stops geocoding</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="gps.html"><a href="gps.html#labeling"><i class="fa fa-check"></i><b>2.4</b> Defining Home and Work Locations</a>
<ul>
<li class="chapter" data-level="2.4.1" data-path="gps.html"><a href="gps.html#seasonal-patterns"><i class="fa fa-check"></i><b>2.4.1</b> Seasonal patterns</a></li>
<li class="chapter" data-level="2.4.2" data-path="gps.html"><a href="gps.html#code-1"><i class="fa fa-check"></i><b>2.4.2</b> Code</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="gps.html"><a href="gps.html#mobility"><i class="fa fa-check"></i><b>2.5</b> Mobility Patterns</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="gps.html"><a href="gps.html#socio-economic-groups"><i class="fa fa-check"></i><b>2.5.1</b> Socio-economic groups</a></li>
<li class="chapter" data-level="2.5.2" data-path="gps.html"><a href="gps.html#selection"><i class="fa fa-check"></i><b>2.5.2</b> Individual’s selection</a></li>
<li class="chapter" data-level="2.5.3" data-path="gps.html"><a href="gps.html#measures"><i class="fa fa-check"></i><b>2.5.3</b> Measures</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="gps.html"><a href="gps.html#migration"><i class="fa fa-check"></i><b>2.6</b> Migration Patterns</a>
<ul>
<li class="chapter" data-level="2.6.1" data-path="gps.html"><a href="gps.html#description"><i class="fa fa-check"></i><b>2.6.1</b> Description</a></li>
<li class="chapter" data-level="2.6.2" data-path="gps.html"><a href="gps.html#user-selection"><i class="fa fa-check"></i><b>2.6.2</b> User selection</a></li>
<li class="chapter" data-level="2.6.3" data-path="gps.html"><a href="gps.html#code-2"><i class="fa fa-check"></i><b>2.6.3</b> Code</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="gps.html"><a href="gps.html#optimization"><i class="fa fa-check"></i><b>2.7</b> Location labeling and parameter optimization</a>
<ul>
<li class="chapter" data-level="2.7.1" data-path="gps.html"><a href="gps.html#ground-truth"><i class="fa fa-check"></i><b>2.7.1</b> Ground truth</a></li>
<li class="chapter" data-level="2.7.2" data-path="gps.html"><a href="gps.html#parameter-optimization"><i class="fa fa-check"></i><b>2.7.2</b> Parameter optimization</a></li>
<li class="chapter" data-level="2.7.3" data-path="gps.html"><a href="gps.html#parameter-configuration-selection"><i class="fa fa-check"></i><b>2.7.3</b> Parameter configuration selection</a></li>
</ul></li>
<li class="part"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="2.8" data-path="gps.html"><a href="gps.html#windex"><i class="fa fa-check"></i><b>2.8</b> Wealth Index</a>
<ul>
<li class="chapter" data-level="2.8.1" data-path="gps.html"><a href="gps.html#variables-to-estimate-the-social-gap-index-in-mexico"><i class="fa fa-check"></i><b>2.8.1</b> Variables to estimate the Social Gap Index in Mexico</a></li>
<li class="chapter" data-level="2.8.2" data-path="gps.html"><a href="gps.html#education"><i class="fa fa-check"></i><b>2.8.2</b> Education</a></li>
<li class="chapter" data-level="2.8.3" data-path="gps.html"><a href="gps.html#household-characteristics"><i class="fa fa-check"></i><b>2.8.3</b> Household Characteristics</a></li>
<li class="chapter" data-level="2.8.4" data-path="gps.html"><a href="gps.html#assets-ownership"><i class="fa fa-check"></i><b>2.8.4</b> Assets Ownership</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>Twitter Analytics - Labor Market</b></span></li>
<li class="chapter" data-level="3" data-path="twitter.html"><a href="twitter.html"><i class="fa fa-check"></i><b>3</b> Labor Market</a>
<ul>
<li class="chapter" data-level="3.1" data-path="twitter.html"><a href="twitter.html#labor-market-analysis-with-twitter-data-1"><i class="fa fa-check"></i><b>3.1</b> Labor market analysis with Twitter data</a></li>
<li class="chapter" data-level="3.2" data-path="twitter.html"><a href="twitter.html#training-data-preparation"><i class="fa fa-check"></i><b>3.2</b> Training data preparation</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="twitter.html"><a href="twitter.html#sampling"><i class="fa fa-check"></i><b>3.2.1</b> Sampling</a></li>
<li class="chapter" data-level="3.2.2" data-path="twitter.html"><a href="twitter.html#labelling"><i class="fa fa-check"></i><b>3.2.2</b> Labelling</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="twitter.html"><a href="twitter.html#finetuning-bert-based-models"><i class="fa fa-check"></i><b>3.3</b> Finetuning BERT-based models</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="twitter.html"><a href="twitter.html#training-the-model"><i class="fa fa-check"></i><b>3.3.1</b> Training the model</a></li>
<li class="chapter" data-level="3.3.2" data-path="twitter.html"><a href="twitter.html#evaluation-on-the-random-set"><i class="fa fa-check"></i><b>3.3.2</b> Evaluation on the random set</a></li>
<li class="chapter" data-level="3.3.3" data-path="twitter.html"><a href="twitter.html#active-learning"><i class="fa fa-check"></i><b>3.3.3</b> Active learning</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="twitter.html"><a href="twitter.html#unemployment-indicators"><i class="fa fa-check"></i><b>3.4</b> Unemployment indicators</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="twitter.html"><a href="twitter.html#building-unemployment-indicators-from-individual-tweets"><i class="fa fa-check"></i><b>3.4.1</b> Building unemployment indicators from individual tweets</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>Twitter Analytics - News</b></span></li>
<li class="chapter" data-level="4" data-path="news.html"><a href="news.html"><i class="fa fa-check"></i><b>4</b> News Analytics</a>
<ul>
<li class="chapter" data-level="4.1" data-path="news.html"><a href="news.html#news-articles"><i class="fa fa-check"></i><b>4.1</b> News articles</a></li>
<li class="chapter" data-level="4.2" data-path="news.html"><a href="news.html#global-vs.-local-news-sentiment-indicators"><i class="fa fa-check"></i><b>4.2</b> Global vs. local news sentiment indicators</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="news.html"><a href="news.html#local-news-sentiment-indicator"><i class="fa fa-check"></i><b>4.2.1</b> Local news sentiment indicator</a></li>
<li class="chapter" data-level="4.2.2" data-path="news.html"><a href="news.html#global-news-sentiment-indicator"><i class="fa fa-check"></i><b>4.2.2</b> Global news sentiment indicator</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="news.html"><a href="news.html#news-sentiment-measures"><i class="fa fa-check"></i><b>4.3</b> News-sentiment measures</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="news.html"><a href="news.html#bag-of-words-model"><i class="fa fa-check"></i><b>4.3.1</b> Bag-of-words model</a></li>
<li class="chapter" data-level="4.3.2" data-path="news.html"><a href="news.html#country-specific-news-sentiment-indicator"><i class="fa fa-check"></i><b>4.3.2</b> Country-specific news sentiment indicator</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="news.html"><a href="news.html#stylized-facts"><i class="fa fa-check"></i><b>4.4</b> Stylized facts</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Big Data Analytics</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="gps" class="section level1" number="2">
<h1><span class="header-section-number">Chapter 2</span> GPS</h1>
<p>In latest years new sources of data have been proven to be valuable assets to understand human behavior and thus
help in the creation of public policies based on evidence. Among those lies mobile phone data which is commonly used
to study spatio-temporal patterns in the form of mobility or social connections. This type of data usually comes in two
flavors; Call Detail Record (CDR), which is basicaly the information generated by a telecom transaction between at least two
devices, i.e. phone calls or SMS and it can be used to determine connections between users and a location proxy given the
connection of the device to the nearest antenna. The second type is GPS data. In present times mobile phones, particularely smart phones,
which global penetration is estimated to be almost 50%, are used for much more than Pier to Pier (P2P) transactions as they
are capable of connecting to the internet through apps. There are companies that partner up with app creators in order to
store information about the usage of their products, this way when used in a phone they store a token with a unique device ID
and time stamp plus any extra information that the user has consent to share, such as geolocation which is obtained via the
high precision GPS anthenas the phones are equiped with plus WiFi triangulation in some cases to upscale it.</p>
<p>We are interested in the latter source of information as the aim of our study is to untangle the universal disparities, if any,
in mobility reduction during the COVID-19 pandemic between socioeconomic groups. We focused our study in 6 middle-income countries (Brazil, Colombia,
Indonesia, Mexico, Philippines and South Africa).</p>

<div id="data" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Data</h2>
<p>The complex task of analysing mobility data given the socioeconomic background of the user requires multiple data sources
because we need a type of data that allow us to study individual spatio-temporal behavior, another one with demographic and
economic information and one to serve as a bridge to the other two.</p>
<div id="gps-data" class="section level3" number="2.1.1">
<h3><span class="header-section-number">2.1.1</span> GPS Data</h3>
<p>Anonymous raw GPS points are provided at a global scale by the <em>Veraset</em> data company in the framework
of the World Bank “Monitoring COVID-19 policy response through human mobility data” project.
Veraset Movements data consists of raw GPS point information from devices all around the World.
In contrast to the majority of GPS data providers, Verasets Movements are sourced from thousands of
Software Development Kit (SDK) to reduce sample biases.
It features a coverage of about 5% of the global population.
In our work, unique-device GPS points are processed and analysed as a proxy of individuals mobility and patterns of visits.
The data at our disposal spans over a period of 17 months, starting from the start of Jan 2020 until the end of May 2021.
In this work multiple countries were analysed to assess the impact of the pandemic and the policy responses across a vast
spectrum of potentially different behaviours.</p>
</div>
<div id="wealth-index-data" class="section level3" number="2.1.2">
<h3><span class="header-section-number">2.1.2</span> Wealth Index Data</h3>
<p>Aiming for universal behaviors is a hard endeavour as there are cultural and economic differences between every country.
This is why we need an homologated number or index that can describe the level of marginalization or deprivation of goods
that comprise the universal definition of poverty. In order to do this we gathered the latest census data from each country
and summarized the level of education, the access to health services and household characteristics and the finest administrative
unit level available. Then we take all of these values and embed them in a new coordinate system given by a Principal component
Analysis (PCA) and take the normalized value of the first component as a proxy to wealth. This approach yields a continuous variable
which we later discretize by quantiles.</p>
</div>
<div id="administrative-boundaries-data" class="section level3" number="2.1.3">
<h3><span class="header-section-number">2.1.3</span> Administrative Boundaries Data</h3>
<p>The country-wise geographical information is given in the form of spatial databases that represent certain areas
with polygons made of vertices in a given cartographic projection, commonly represented by their longitude and latitude
coordinate pair. These areas have labels that can be linked to the census data allowing us to get a spatial representation
of the previously mentioned Wealth Index. These files are usually given by the Statistics or Geography Institute of each nation.
Using Geographical Information Software (GIS), in this case Sedona for Spark, we are able to assign a geographical area to
each one of the GPS points given by the <em>Veraset</em> dataset and which will allow us to determine a probable home location
inside an administrative polygon to each user and assign a wealth category to them.</p>

</div>
</div>
<div id="geocode" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Geocode</h2>
<p>One of the first step in our pipeline is to associate to each point of a gps trace for a user or an user’s stop location
the smallest administrative unit available
in our shapefiles for one country.
This will allow us to join the gps data with the census
and other indices based on the same shapefiles, and to group by larger administrative units (such
as city or region for more general analysis. We will refer to the process of associating a (latitude,longitude) tuple to a shape (corresponding usually to the smallest availabe admin division)
as geocoding.</p>
<p>In this example, we will show how this can be done for the single pings that compose an user’s
GPS trace, but the procedure is exactly the same for the stop locations case described in <a href="gps.html#stops">2.3</a></p>
<p>// The data we are utilizing was provided by Veraset. If a user has installed one of the Veraset’s
// partners’ apps on his or her mobile phone, the users’ position and position’s accuracy is sent to the Veraset server where
// it is recorded at regular intervals.</p>
<div id="efficient-spatial-joining-and-geospatial-indexing" class="section level3" number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> Efficient spatial joining and Geospatial Indexing</h3>
<p>To be able to deal with billions of points, we need an efficient way to perform spatial queries. Since it is not feasible
to join directly thousands of shapes with the billions of points, for computational reasons, we need an efficient way to reduce the
computational cost by checking only few shapes that are in the surroundings of the point we want to join.
As geo-spatial index we use the <a href="https://eng.uber.com/h3/">H3</a> indexing created by Uber which partitions the World in hexagons.
Since the admin shapes cannot be exactly covered by hexagons that are included in the shape. The hexagon should have a size
that is reasonable for a quick spatial join and hence be quite large: this implies we
run the risk of mis-joining pings that end up close to the borders of the shapes.</p>
<p>// TODO: put an image or create one</p>
<p>To overcome this problem we perform two joins: the first one will use a geospatial index, and will get the shapes that are close enough to
the points we want to geocode, after buffering the shapes to be sure that any hexagon that is around the border of a shape
is included in the join. The second join will be only between these subsets of shapes selected and the actual point. This greatly
reduces the computational cost and makes this problem tractable.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:h3fig"></span>
<img src="big-daa_files/figure-html/h3fig-1.png" alt="H3 indexing representation. Figure taken from the H3 website referenced above." width="80%" />
<p class="caption">
Figure 2.1: H3 indexing representation. Figure taken from the H3 website referenced above.
</p>
</div>
</div>
<div id="code" class="section level3" number="2.2.2">
<h3><span class="header-section-number">2.2.2</span> Code</h3>
<div id="loading-administrative-units" class="section level4" number="2.2.2.1">
<h4><span class="header-section-number">2.2.2.1</span> Loading administrative units</h4>
<p>We first load the administrative files containing the polygons and the wealth index information, then, using <em>Apache Sedona</em> (previously named GeoSpark) we
can transform the Well-Known Text representation of the polygons (WKT) into geometries and create a buffer around them.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="gps.html#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> admin <span class="op">=</span> spark<span class="op">.</span>read<span class="op">.</span><span class="fu">option</span><span class="op">(</span><span class="st">&quot;header&quot;</span><span class="op">,</span><span class="st">&quot;true&quot;</span><span class="op">).</span><span class="fu">csv</span><span class="op">(</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;admin_path&quot;</span><span class="op">)</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> <span class="fu">c</span><span class="op">(</span><span class="st">&quot;country&quot;</span><span class="op">)</span> <span class="op">+</span> <span class="st">&quot;/admin.csv&quot;</span><span class="op">)</span></span>
<span id="cb1-2"><a href="gps.html#cb1-2" aria-hidden="true" tabindex="-1"></a>admin<span class="op">.</span><span class="fu">createOrReplaceTempView</span><span class="op">(</span><span class="st">&quot;admin&quot;</span><span class="op">)</span></span>
<span id="cb1-3"><a href="gps.html#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="gps.html#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="gps.html#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> query <span class="op">=</span> <span class="st">&quot;SELECT geom_id AS geom_id, ST_GeomFromText(geometry) as polygon FROM admin&quot;</span></span>
<span id="cb1-6"><a href="gps.html#cb1-6" aria-hidden="true" tabindex="-1"></a>admin <span class="op">=</span> spark<span class="op">.</span><span class="fu">sql</span><span class="op">(</span>query<span class="op">)</span></span>
<span id="cb1-7"><a href="gps.html#cb1-7" aria-hidden="true" tabindex="-1"></a>admin<span class="op">.</span><span class="fu">createOrReplaceTempView</span><span class="op">(</span><span class="st">&quot;admin_with_polygons&quot;</span><span class="op">)</span></span>
<span id="cb1-8"><a href="gps.html#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="gps.html#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="gps.html#cb1-10" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> <span class="st">&quot;SELECT *, ST_Buffer(polygon, 0.005) as polygon_buff FROM admin_with_polygons&quot;</span></span>
<span id="cb1-11"><a href="gps.html#cb1-11" aria-hidden="true" tabindex="-1"></a>admin <span class="op">=</span> spark<span class="op">.</span><span class="fu">sql</span><span class="op">(</span>query<span class="op">)</span></span></code></pre></div>
</div>
<div id="loading-ping-data-and-h3-indexing" class="section level4" number="2.2.2.2">
<h4><span class="header-section-number">2.2.2.2</span> Loading ping data and h3 indexing</h4>
<p>We will also be needing the ping data from <em>Veraset</em>. In our case we’ll load them from the following table depending on the country.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="gps.html#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> table <span class="op">=</span> <span class="ss">s&quot;</span><span class="st">pings.</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;source&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st">_</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;country&quot;</span><span class="op">)</span><span class="ss">}&quot;</span></span></code></pre></div>
<p>Then we’re able to proceed indexing the pings and the buffered geometries.
In order to do this we only take those pings that have correct longitude and latitude
values and threshold the accuracy (provided in the data) of the GPS point location. That last part is a confidence
estimate of the real location of the device, we can usually see this in our phone when using a geolocation app which
gives you information such as “accuracy &lt; 3m” which means that the actual position could be anywhere in a 3m radius circle with
center at the position given.</p>
<p>When reading the pings, we first filter the ones having wrong coordinates or an accuracy &gt; than 1km, and add to the spark
table a column containing the county’s offset (if a country has only one timezone), since we want to compare different
countries for the same time of the days, we will use this offset to align all the timestamps. We then index each buffered
admin shape and ping using h3.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="gps.html#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> pings <span class="op">=</span> spark<span class="op">.</span><span class="fu">sql</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">SELECT lat, lon, accuracy, timestamp AS time, device_id AS user_id FROM </span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;input_table&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st"> WHERE country = &#39;</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;country&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st">&#39;</span><span class="ss">&quot;</span><span class="op">)</span></span>
<span id="cb3-2"><a href="gps.html#cb3-2" aria-hidden="true" tabindex="-1"></a>pings<span class="op">.</span><span class="fu">filter</span><span class="op">(</span>$<span class="st">&quot;lat&quot;</span> <span class="op">&gt;</span> <span class="op">-</span><span class="dv">90</span> <span class="op">&amp;&amp;</span> $<span class="st">&quot;lat&quot;</span> <span class="op">&lt;</span> <span class="dv">90</span> <span class="op">&amp;&amp;</span> $<span class="st">&quot;lon&quot;</span> <span class="op">&gt;</span> <span class="op">-</span><span class="dv">180</span> <span class="op">&amp;&amp;</span> $<span class="st">&quot;lon&quot;</span> <span class="op">&lt;</span> <span class="dv">180</span> <span class="op">&amp;&amp;</span> $<span class="st">&quot;accuracy&quot;</span> <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> $<span class="st">&quot;accuracy&quot;</span> <span class="op">&lt;=</span> <span class="dv">1000</span><span class="op">)</span></span>
<span id="cb3-3"><a href="gps.html#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;country&quot;</span><span class="op">)</span> <span class="op">==</span> <span class="st">&quot;CO&quot;</span><span class="op">){</span></span>
<span id="cb3-4"><a href="gps.html#cb3-4" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> pings<span class="op">.</span><span class="fu">withColumn</span><span class="op">(</span><span class="st">&quot;offset&quot;</span><span class="op">,</span> <span class="fu">lit</span><span class="op">(-</span><span class="dv">5</span><span class="op">*</span><span class="dv">60</span><span class="op">*</span><span class="dv">60</span><span class="op">))</span> <span class="co">//colombia offset</span></span>
<span id="cb3-5"><a href="gps.html#cb3-5" aria-hidden="true" tabindex="-1"></a>  pings<span class="op">.</span><span class="fu">printSchema</span><span class="op">()</span></span>
<span id="cb3-6"><a href="gps.html#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-7"><a href="gps.html#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="gps.html#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb3-9"><a href="gps.html#cb3-9" aria-hidden="true" tabindex="-1"></a>pings <span class="op">=</span> pings<span class="op">.</span><span class="fu">withColumn</span><span class="op">(</span><span class="st">&quot;time&quot;</span><span class="op">,</span> <span class="fu">col</span><span class="op">(</span><span class="st">&quot;time&quot;</span><span class="op">)</span> <span class="op">+</span> <span class="fu">col</span><span class="op">(</span><span class="st">&quot;offset&quot;</span><span class="op">)).</span><span class="fu">withColumn</span><span class="op">(</span><span class="st">&quot;h3index&quot;</span><span class="op">,</span> <span class="fu">geoToH3</span><span class="op">(</span><span class="fu">col</span><span class="op">(</span><span class="st">&quot;lat&quot;</span><span class="op">),</span> <span class="fu">col</span><span class="op">(</span><span class="st">&quot;lon&quot;</span><span class="op">),</span> <span class="fu">lit</span><span class="op">(</span>res<span class="op">)))</span></span>
<span id="cb3-10"><a href="gps.html#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="gps.html#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> adminH3 <span class="op">=</span> admin<span class="op">.</span><span class="fu">withColumn</span><span class="op">(</span><span class="st">&quot;h3index&quot;</span><span class="op">,</span> <span class="fu">multiPolygonToH3</span><span class="op">(</span><span class="fu">col</span><span class="op">(</span><span class="st">&quot;polygon_buff&quot;</span><span class="op">),</span> <span class="fu">lit</span><span class="op">(</span>res<span class="op">))).</span><span class="fu">select</span><span class="op">(</span><span class="st">&quot;geom_id&quot;</span><span class="op">,</span> <span class="st">&quot;h3index&quot;</span><span class="op">).</span><span class="fu">withColumn</span><span class="op">(</span><span class="st">&quot;h3index&quot;</span><span class="op">,</span> <span class="fu">explode</span><span class="op">(</span>$<span class="st">&quot;h3index&quot;</span><span class="op">))</span></span>
<span id="cb3-12"><a href="gps.html#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="gps.html#cb3-13" aria-hidden="true" tabindex="-1"></a>pings<span class="op">.</span><span class="fu">createOrReplaceTempView</span><span class="op">(</span><span class="st">&quot;pingsH3&quot;</span><span class="op">)</span></span>
<span id="cb3-14"><a href="gps.html#cb3-14" aria-hidden="true" tabindex="-1"></a>adminH3<span class="op">.</span><span class="fu">createOrReplaceTempView</span><span class="op">(</span><span class="st">&quot;adminH3&quot;</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div id="initial-coarse-geo-spatial-join-with-shapefiles" class="section level3" number="2.2.3">
<h3><span class="header-section-number">2.2.3</span> Initial coarse geo-spatial join with shapefiles</h3>
<p>We then perform the first approximated spatial join using the spatial index and write it on an intermediate table</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="gps.html#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> query <span class="op">=</span> <span class="st">&quot;&quot;&quot;SELECT p.time</span></span>
<span id="cb4-2"><a href="gps.html#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="st">                    , p.user_id</span></span>
<span id="cb4-3"><a href="gps.html#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="st">                    , p.lat</span></span>
<span id="cb4-4"><a href="gps.html#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="st">                    , p.lon</span></span>
<span id="cb4-5"><a href="gps.html#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="st">                    , p.accuracy</span></span>
<span id="cb4-6"><a href="gps.html#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="st">                    , s.geom_id</span></span>
<span id="cb4-7"><a href="gps.html#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="st">                FROM pingsH3 AS p</span></span>
<span id="cb4-8"><a href="gps.html#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="st">                INNER JOIN adminH3 AS s</span></span>
<span id="cb4-9"><a href="gps.html#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="st">                ON (p.h3index = s.h3index)&quot;&quot;&quot;</span></span>
<span id="cb4-10"><a href="gps.html#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="gps.html#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> pings_geocoded <span class="op">=</span> spark<span class="op">.</span><span class="fu">sql</span><span class="op">(</span>query<span class="op">)</span></span>
<span id="cb4-12"><a href="gps.html#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="gps.html#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> out_table_temp <span class="op">=</span> <span class="ss">s&quot;</span><span class="st">pings.</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;source&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st">_</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;country&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st">_geocoded_temp</span><span class="ss">&quot;</span></span>
<span id="cb4-14"><a href="gps.html#cb4-14" aria-hidden="true" tabindex="-1"></a>pings_geocoded<span class="op">.</span>write<span class="op">.</span><span class="fu">format</span><span class="op">(</span><span class="st">&quot;delta&quot;</span><span class="op">).</span><span class="fu">mode</span><span class="op">(</span><span class="st">&quot;overwrite&quot;</span><span class="op">).</span><span class="fu">saveAsTable</span><span class="op">(</span>out_table_temp<span class="op">)</span></span></code></pre></div>
</div>
<div id="final-exact-join-with-a-subset-of-the-shapefiles" class="section level3" number="2.2.4">
<h3><span class="header-section-number">2.2.4</span> Final exact join with a subset of the shapefiles</h3>
<p>Finally perform the accurate spatial join on the reduced subset of shapes and pings without the spatial index and save it.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="gps.html#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> out_table_temp <span class="op">=</span> <span class="ss">s&quot;</span><span class="st">pings.</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;source&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st">_</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;country&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st">_geocoded_temp</span><span class="ss">&quot;</span></span>
<span id="cb5-2"><a href="gps.html#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="gps.html#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> admin <span class="op">=</span> spark<span class="op">.</span><span class="fu">sql</span><span class="op">(</span><span class="ss">s&quot;</span><span class="st">select geom_id, polygon from admin_with_polygon</span><span class="ss">&quot;</span><span class="op">)</span></span>
<span id="cb5-4"><a href="gps.html#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pings_geo <span class="op">=</span> spark<span class="op">.</span>read<span class="op">.</span><span class="fu">table</span><span class="op">(</span>out_table_temp<span class="op">)</span></span>
<span id="cb5-5"><a href="gps.html#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> pings_geo_pol <span class="op">=</span> pings_geo<span class="op">.</span><span class="fu">join</span><span class="op">(</span><span class="fu">broadcast</span><span class="op">(</span>admin<span class="op">),</span> on<span class="op">=</span><span class="er">&#39;</span>geom_id<span class="er">&#39;</span><span class="op">)</span></span>
<span id="cb5-6"><a href="gps.html#cb5-6" aria-hidden="true" tabindex="-1"></a>pings_geo_pol<span class="op">.</span><span class="fu">createOrReplaceTempView</span><span class="op">(</span><span class="st">&quot;pings_geo&quot;</span><span class="op">)</span></span>
<span id="cb5-7"><a href="gps.html#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="gps.html#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> query <span class="op">=</span> <span class="st">&quot;SELECT *, ST_Point(cast(lon as Decimal(13,10)), cast(lat as Decimal(13,10))) as point FROM pings_geo&quot;</span></span>
<span id="cb5-9"><a href="gps.html#cb5-9" aria-hidden="true" tabindex="-1"></a>pings_geo_pol <span class="op">=</span> spark<span class="op">.</span><span class="fu">sql</span><span class="op">(</span>query<span class="op">)</span></span>
<span id="cb5-10"><a href="gps.html#cb5-10" aria-hidden="true" tabindex="-1"></a>pings_geo_pol<span class="op">.</span><span class="fu">createOrReplaceTempView</span><span class="op">(</span><span class="st">&quot;pings_geo&quot;</span><span class="op">)</span></span>
<span id="cb5-11"><a href="gps.html#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="gps.html#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> query <span class="op">=</span> <span class="st">&quot;SELECT * FROM pings_geo WHERE ST_Intersects(point, polygon)&quot;</span></span>
<span id="cb5-13"><a href="gps.html#cb5-13" aria-hidden="true" tabindex="-1"></a>pings_geo_pol <span class="op">=</span> spark<span class="op">.</span><span class="fu">sql</span><span class="op">(</span>query<span class="op">).</span><span class="fu">drop</span><span class="op">(</span><span class="st">&quot;polygon&quot;</span><span class="op">,</span> <span class="st">&quot;point&quot;</span><span class="op">,</span> <span class="st">&quot;valid&quot;</span><span class="op">)</span></span>
<span id="cb5-14"><a href="gps.html#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="gps.html#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> out_table_temp <span class="op">=</span> <span class="ss">s&quot;</span><span class="st">pings.</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;source&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st">_</span><span class="ss">${</span><span class="fu">c</span><span class="op">(</span><span class="st">&quot;country&quot;</span><span class="op">)</span><span class="ss">}</span><span class="st">_geocoded</span><span class="ss">&quot;</span></span>
<span id="cb5-16"><a href="gps.html#cb5-16" aria-hidden="true" tabindex="-1"></a>pings_geo_pol<span class="op">.</span>write<span class="op">.</span><span class="fu">format</span><span class="op">(</span><span class="st">&quot;delta&quot;</span><span class="op">).</span><span class="fu">mode</span><span class="op">(</span><span class="st">&quot;overwrite&quot;</span><span class="op">).</span><span class="fu">saveAsTable</span><span class="op">(</span>out_table<span class="op">)</span></span></code></pre></div>

</div>
</div>
<div id="stops" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Finding Stops</h2>
<div id="definition" class="section level3" number="2.3.1">
<h3><span class="header-section-number">2.3.1</span> Definition</h3>
<p>Pings recorded from the gps devices are often noisy: unless an user is perfectly still in a place, the mobile will record
slightly different positions. As an example, if an user is at home and he moves between the different rooms of the house, we want to
group all the pings under a single label, home, to analyze the time spent at each location.
This would not be possible by considering individual pings. A standard procedure to
reduce the noise is to compute stop locations, by spatially and temporally clustering the raw pings.
### Infostop</p>
<p>In order to do this we need both the spatial and the temporal data from each ping. This
is, how far are consecutive pings from each other in time and space. We rely on the first part of the
<a href="https://arxiv.org/pdf/2003.14370.pdf">infostop</a> algorithm to detect stop-locations
or <em>stays</em>.
Infostop is based in some heuristics:</p>
<ul>
<li><span class="math inline">\(r_1\)</span>: The maximum distance between any pair of points within the same stop.</li>
<li><span class="math inline">\(n_{min}\)</span>: The minimum number of points that make up a stop.</li>
<li><span class="math inline">\(t_{min}\)</span>: The minimum duration of a stop.</li>
<li><span class="math inline">\(t_{max}\)</span>: The maximum time difference between two consecutive pings.</li>
</ul>
<p>Then in order to have a <em>stop</em> we would need to satisfy that some consecutive pings are all less than <span class="math inline">\(r_1\)</span> meters apart,
the time span between the first and the last pings is more than <span class="math inline">\(t_{min}\)</span> seconds, there’s no more than <span class="math inline">\(t_{max}\)</span>
seconds between consecutive pairs and each stop cannot be composed of less than <span class="math inline">\(n_{min}\)</span> pings.</p>
<p>Particularly we use the Python function <code>get_stationary_events()</code> in the <a href="https://github.com/ulfaslak/infostop">Infostop package</a>,
that is a wrapper around an efficient c++ implementation for computing stationary events, i.e. points of a trace that are
close in time and space and that can be grouped together under a single label. Each time we find a stationary event, we
associate it to a stop location, with as coordinates the centroid of the points that form the event and as duration
the difference in time between the first point of the event and the last point of the event.</p>
<p>Differently from infostop, we choose to use DBSCAN instead of Infomap to cluster stop locations.
### Code
#### Data preparation</p>
<p>Once we load the required data, we make sure that they meet the timezone metadata requirements and that their coordinates
are valid geographical points.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="gps.html#cb6-1" aria-hidden="true" tabindex="-1"></a>filter_string <span class="op">=</span> <span class="ss">f&quot;accuracy &gt;=0 AND accuracy &lt;= 200 AND lat &gt; -90 AND lat &lt; 90 AND lon &gt; -180 AND lon &lt; 180&quot;</span></span>
<span id="cb6-2"><a href="gps.html#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="gps.html#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> tz: <span class="co"># add a check on TZ_OFFSET</span></span>
<span id="cb6-4"><a href="gps.html#cb6-4" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> spark.sql(<span class="ss">f&quot;SELECT  device_id AS user_id, lat, lon, accuracy, timestamp, TZ_OFFSET_SEC FROM default.veraset_</span><span class="sc">{c.</span>country<span class="sc">}</span><span class="ss">_tz WHERE country = &#39;</span><span class="sc">{c.</span>country<span class="sc">}</span><span class="ss">&#39; AND </span><span class="sc">{</span>filter_string<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-5"><a href="gps.html#cb6-5" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> (pings</span>
<span id="cb6-6"><a href="gps.html#cb6-6" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;epoch_time&#39;</span>, col(<span class="st">&quot;timestamp&quot;</span>) <span class="op">+</span> col(<span class="st">&quot;TZ_OFFSET_SEC&quot;</span>).cast(<span class="st">&quot;long&quot;</span>))</span>
<span id="cb6-7"><a href="gps.html#cb6-7" aria-hidden="true" tabindex="-1"></a>           .drop(<span class="st">&quot;TZ_OFFSET_SEC&quot;</span>, <span class="st">&quot;timestamp&quot;</span>))</span>
<span id="cb6-8"><a href="gps.html#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> tz:</span>
<span id="cb6-9"><a href="gps.html#cb6-9" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> spark.sql(<span class="ss">f&quot;SELECT  device_id AS user_id, lat, lon, accuracy, timestamp FROM default.veraset_primary_1  WHERE country = &#39;</span><span class="sc">{c.</span>country<span class="sc">}</span><span class="ss">&#39; AND </span><span class="sc">{</span>filter_string<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-10"><a href="gps.html#cb6-10" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> (pings</span>
<span id="cb6-11"><a href="gps.html#cb6-11" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;time&#39;</span>, F.to_timestamp(<span class="st">&#39;timestamp&#39;</span>))</span>
<span id="cb6-12"><a href="gps.html#cb6-12" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;new_time&#39;</span>, F.from_utc_timestamp(<span class="st">&#39;time&#39;</span>, tz))</span>
<span id="cb6-13"><a href="gps.html#cb6-13" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;epoch_time&#39;</span>, F.unix_timestamp(<span class="st">&#39;new_time&#39;</span>))</span>
<span id="cb6-14"><a href="gps.html#cb6-14" aria-hidden="true" tabindex="-1"></a>           .drop(<span class="st">&#39;timestamp&#39;</span>, <span class="st">&#39;time&#39;</span>, <span class="st">&#39;new_time&#39;</span>))</span>
<span id="cb6-15"><a href="gps.html#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb6-16"><a href="gps.html#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">raise</span> <span class="pp">Exception</span> (<span class="st">&quot;Undefined time zone in config or tz_offset in input table&quot;</span>)</span></code></pre></div>
<div id="get-stop-locations" class="section level4" number="2.3.1.1">
<h4><span class="header-section-number">2.3.1.1</span> Get stop locations</h4>
<p>Now we have the data ready to identify stops, we only need to sort pings by their timestamp for each user.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="gps.html#cb7-1" aria-hidden="true" tabindex="-1"></a>sl <span class="op">=</span> (pings</span>
<span id="cb7-2"><a href="gps.html#cb7-2" aria-hidden="true" tabindex="-1"></a>      .orderBy(<span class="st">&quot;epoch_time&quot;</span>)</span>
<span id="cb7-3"><a href="gps.html#cb7-3" aria-hidden="true" tabindex="-1"></a>      .groupBy(<span class="st">&quot;user_id&quot;</span>)</span>
<span id="cb7-4"><a href="gps.html#cb7-4" aria-hidden="true" tabindex="-1"></a>      .<span class="bu">apply</span>(get_stop_location, args<span class="op">=</span>(radius, stay_time,</span>
<span id="cb7-5"><a href="gps.html#cb7-5" aria-hidden="true" tabindex="-1"></a>             min_pts_per_stop_location, max_time_stop_location,</span>
<span id="cb7-6"><a href="gps.html#cb7-6" aria-hidden="true" tabindex="-1"></a>             max_accuracy, db_scan_radius))</span>
<span id="cb7-7"><a href="gps.html#cb7-7" aria-hidden="true" tabindex="-1"></a>      .dropna())</span></code></pre></div>
<p>Where the user defined function <code>get_stop_location()</code> composed by other functions which at the end will yield
a data frame with user id, stop beginning timestamp, stop end timestamp, a centroid coordinate pair from the original pings,
a cluster label from a <a href="https://www.aaai.org/Papers/KDD/1996/KDD96-037.pdf">DBSCAN clustering algorithm</a>, the median accuracy of
the pings and the total number of pings that compose the given stop.</p>
<p>For DBSCAN we also use <span class="math inline">\(\epsilon=50m\)</span> and the minimum accuracy for us to keep a ping is <span class="math inline">\(100m\)</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="gps.html#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_intervals(centroids, labels, timestamps, accuracy, input_data):</span>
<span id="cb8-2"><a href="gps.html#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># if the label is -1 it means that the point doesn&#39;t belong to any cluster. Otherwise there should be at least 2 points for a stop locations</span></span>
<span id="cb8-3"><a href="gps.html#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># and they should</span></span>
<span id="cb8-4"><a href="gps.html#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     assert (len(centroids) == len(community_labels))</span></span>
<span id="cb8-5"><a href="gps.html#cb8-5" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-6"><a href="gps.html#cb8-6" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-7"><a href="gps.html#cb8-7" aria-hidden="true" tabindex="-1"></a>    trajectory <span class="op">=</span> []</span>
<span id="cb8-8"><a href="gps.html#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(labels):</span>
<span id="cb8-9"><a href="gps.html#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> labels[i] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb8-10"><a href="gps.html#cb8-10" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-11"><a href="gps.html#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-12"><a href="gps.html#cb8-12" aria-hidden="true" tabindex="-1"></a>            start_index <span class="op">=</span> i</span>
<span id="cb8-13"><a href="gps.html#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(labels)) <span class="kw">and</span> (labels[i] <span class="op">==</span> labels[i <span class="op">+</span> <span class="dv">1</span>]):</span>
<span id="cb8-14"><a href="gps.html#cb8-14" aria-hidden="true" tabindex="-1"></a>                i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-15"><a href="gps.html#cb8-15" aria-hidden="true" tabindex="-1"></a>            trajectory.append((timestamps[start_index], timestamps[i], <span class="op">*</span>centroids[seen],</span>
<span id="cb8-16"><a href="gps.html#cb8-16" aria-hidden="true" tabindex="-1"></a>                               np.median(accuracy[start_index: i]), i <span class="op">-</span> start_index <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb8-17"><a href="gps.html#cb8-17" aria-hidden="true" tabindex="-1"></a>            seen <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-18"><a href="gps.html#cb8-18" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-19"><a href="gps.html#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="gps.html#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> trajectory</span>
<span id="cb8-21"><a href="gps.html#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="gps.html#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_infostop(data, r1, min_staying_time, min_size, max_time_between, distance_metric):</span>
<span id="cb8-23"><a href="gps.html#cb8-23" aria-hidden="true" tabindex="-1"></a>    data_assertions(data)</span>
<span id="cb8-24"><a href="gps.html#cb8-24" aria-hidden="true" tabindex="-1"></a>    centroids, stat_labels <span class="op">=</span> get_stationary_events(</span>
<span id="cb8-25"><a href="gps.html#cb8-25" aria-hidden="true" tabindex="-1"></a>        data[:, :<span class="dv">3</span>], r1, min_size, min_staying_time, max_time_between, distance_metric)</span>
<span id="cb8-26"><a href="gps.html#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> compute_intervals(centroids, stat_labels, data[:, <span class="dv">2</span>], data[:, <span class="dv">3</span>], data)</span>
<span id="cb8-27"><a href="gps.html#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="gps.html#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="gps.html#cb8-29" aria-hidden="true" tabindex="-1"></a>schema_df <span class="op">=</span> StructType([</span>
<span id="cb8-30"><a href="gps.html#cb8-30" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;user_id&#39;</span>, StringType(), <span class="va">False</span>),</span>
<span id="cb8-31"><a href="gps.html#cb8-31" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;t_start&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb8-32"><a href="gps.html#cb8-32" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;t_end&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb8-33"><a href="gps.html#cb8-33" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;lat&#39;</span>, DoubleType(), <span class="va">False</span>),</span>
<span id="cb8-34"><a href="gps.html#cb8-34" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;lon&#39;</span>, DoubleType(), <span class="va">False</span>),</span>
<span id="cb8-35"><a href="gps.html#cb8-35" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;cluster_label&#39;</span>, LongType(), <span class="va">True</span>),</span>
<span id="cb8-36"><a href="gps.html#cb8-36" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;median_accuracy&#39;</span>, DoubleType(), <span class="va">True</span>),</span>
<span id="cb8-37"><a href="gps.html#cb8-37" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;total_pings_stop&#39;</span>, LongType(), <span class="va">True</span>),</span>
<span id="cb8-38"><a href="gps.html#cb8-38" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb8-39"><a href="gps.html#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="at">@pandas_udf</span>(schema_df, PandasUDFType.GROUPED_MAP)</span>
<span id="cb8-40"><a href="gps.html#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_stop_location(df, radius, stay_time, min_pts_per_stop_location, max_time_stop_location, max_accuracy, db_scan_radius):</span>
<span id="cb8-41"><a href="gps.html#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="gps.html#cb8-42" aria-hidden="true" tabindex="-1"></a>    identifier <span class="op">=</span> df[<span class="st">&#39;user_id&#39;</span>].values[<span class="dv">0</span>]</span>
<span id="cb8-43"><a href="gps.html#cb8-43" aria-hidden="true" tabindex="-1"></a>    df.sort_values(by<span class="op">=</span><span class="st">&#39;epoch_time&#39;</span>, inplace<span class="op">=</span><span class="va">True</span>)  <span class="co"># shouldnt be necessary</span></span>
<span id="cb8-44"><a href="gps.html#cb8-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-45"><a href="gps.html#cb8-45" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> df[[<span class="st">&quot;lat&quot;</span>, <span class="st">&quot;lon&quot;</span>, <span class="st">&#39;epoch_time&#39;</span>, <span class="st">&quot;accuracy&quot;</span>]].values</span>
<span id="cb8-46"><a href="gps.html#cb8-46" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> run_infostop(data, r1<span class="op">=</span>radius, min_staying_time<span class="op">=</span>stay_time, min_size<span class="op">=</span>min_pts_per_stop_location,</span>
<span id="cb8-47"><a href="gps.html#cb8-47" aria-hidden="true" tabindex="-1"></a>                       max_time_between<span class="op">=</span>max_time_stop_location, distance_metric<span class="op">=</span><span class="st">&#39;haversine&#39;</span>)</span>
<span id="cb8-48"><a href="gps.html#cb8-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-49"><a href="gps.html#cb8-49" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(res, columns<span class="op">=</span>[</span>
<span id="cb8-50"><a href="gps.html#cb8-50" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;t_start&quot;</span>,  <span class="st">&quot;t_end&quot;</span>, <span class="st">&quot;lat&quot;</span>, <span class="st">&quot;lon&quot;</span>, <span class="st">&quot;median_accuracy&quot;</span>, <span class="st">&quot;total_pings_stop&quot;</span>])</span>
<span id="cb8-51"><a href="gps.html#cb8-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-52"><a href="gps.html#cb8-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># new filtering step based on median accuracy</span></span>
<span id="cb8-53"><a href="gps.html#cb8-53" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df[df[<span class="st">&#39;median_accuracy&#39;</span>] <span class="op">&lt;</span> max_accuracy]</span>
<span id="cb8-54"><a href="gps.html#cb8-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-55"><a href="gps.html#cb8-55" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">&#39;user_id&#39;</span>] <span class="op">=</span> identifier</span>
<span id="cb8-56"><a href="gps.html#cb8-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> df.empty:</span>
<span id="cb8-57"><a href="gps.html#cb8-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">#       df[&#39;cluster_label&#39;] = get_labels(df[[&#39;lat&#39;, &#39;lon&#39;]])</span></span>
<span id="cb8-58"><a href="gps.html#cb8-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># notice that we don&#39;t have noise here, since any point that we consider is a stop location and hence has been already pre filtered by run_infostop (min_samples = 1 =&gt; no label =-1)</span></span>
<span id="cb8-59"><a href="gps.html#cb8-59" aria-hidden="true" tabindex="-1"></a>        db <span class="op">=</span> DBSCAN(eps<span class="op">=</span>db_scan_radius, min_samples<span class="op">=</span><span class="dv">1</span>, metric<span class="op">=</span><span class="st">&#39;haversine&#39;</span>,</span>
<span id="cb8-60"><a href="gps.html#cb8-60" aria-hidden="true" tabindex="-1"></a>                    algorithm<span class="op">=</span><span class="st">&#39;ball_tree&#39;</span>).fit(np.radians(df[[<span class="st">&#39;lat&#39;</span>, <span class="st">&#39;lon&#39;</span>]].values))</span>
<span id="cb8-61"><a href="gps.html#cb8-61" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">&#39;cluster_label&#39;</span>] <span class="op">=</span> db.labels_</span>
<span id="cb8-62"><a href="gps.html#cb8-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-63"><a href="gps.html#cb8-63" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">&#39;cluster_label&#39;</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-64"><a href="gps.html#cb8-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code></pre></div>
</div>
</div>
<div id="clustering-recurrent-stops" class="section level3" number="2.3.2">
<h3><span class="header-section-number">2.3.2</span> Clustering recurrent stops</h3>
<p>The clustering part is where our approach differs from the Infostop one, as the assign cluster labels by building a network of
stops if they’re located closer than a distance <span class="math inline">\(r_2\)</span> and then use the <a href="https://www.mapequation.org/assets/publications/RosvallBergstromPNAS2008Full.pdf">Infomap</a>
community detection algorithm while we proceed by clustering with DBSCAN as previously discussed. It is important to notice that
these clusters don’t depend on the time but only on the spatial distribution as we are interested in finding recurrent
visited locations.</p>
<p>Finally we split those stops that span multiple days into mutiple stops that are within a day: i.e. if we have a stop location
that spans from 22pm to 1am, we will split it into a stop location from 22pm to 23.59pm and another stop location from
00.00am to 1am.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="gps.html#cb9-1" aria-hidden="true" tabindex="-1"></a>sl <span class="op">=</span> (sl</span>
<span id="cb9-2"><a href="gps.html#cb9-2" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;total_duration_stop_location&quot;</span>, F.col(<span class="st">&quot;t_end&quot;</span>) <span class="op">-</span> F.col(<span class="st">&quot;t_start&quot;</span>))</span>
<span id="cb9-3"><a href="gps.html#cb9-3" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&#39;my_list&#39;</span>, make_list(F.to_timestamp(col(<span class="st">&#39;t_start&#39;</span>)), F.to_timestamp(col(<span class="st">&#39;t_end&#39;</span>))))</span>
<span id="cb9-4"><a href="gps.html#cb9-4" aria-hidden="true" tabindex="-1"></a>      .drop(<span class="st">&#39;t_start&#39;</span>, <span class="st">&#39;t_end&#39;</span>)</span>
<span id="cb9-5"><a href="gps.html#cb9-5" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;tmp&quot;</span>, F.explode(<span class="st">&quot;my_list&quot;</span>))</span>
<span id="cb9-6"><a href="gps.html#cb9-6" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;t_start&quot;</span>, F.col(<span class="st">&quot;tmp&quot;</span>).t_start)</span>
<span id="cb9-7"><a href="gps.html#cb9-7" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;t_end&quot;</span>, F.col(<span class="st">&quot;tmp&quot;</span>).t_end)</span>
<span id="cb9-8"><a href="gps.html#cb9-8" aria-hidden="true" tabindex="-1"></a>      .drop(<span class="st">&quot;tmp&quot;</span>, <span class="st">&quot;my_list&quot;</span>)</span>
<span id="cb9-9"><a href="gps.html#cb9-9" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;duration&quot;</span>, F.col(<span class="st">&quot;t_end&quot;</span>) <span class="op">-</span> F.col(<span class="st">&quot;t_start&quot;</span>)))</span></code></pre></div>
</div>
<div id="appending-pings-from-recent-dates" class="section level3" number="2.3.3">
<h3><span class="header-section-number">2.3.3</span> Appending pings from recent dates</h3>
<p>GPS data is passively gathered and as so it’s continiously growing, this translates in the need for contiously find stops and
assign cluster labels to them. This whole process is very computationally expensive and running it on the whole data would be
highly inefficient, this is why we keep old stops and only compute new ones, but there’s no way around the clustering part as
the labels can change every time. Fortunately the number of stops is several order magnitudes lower than the pings as the smallest
stop has at least two of them and we drop those that didn’t make up a stop.</p>
</div>
<div id="stops-geocoding" class="section level3" number="2.3.4">
<h3><span class="header-section-number">2.3.4</span> Stops geocoding</h3>
<p>Now that our data is composed by new aggregated points we replicate the indexing from <a href="gps.html#geocode">2.2</a> but with the stops instead
of the pings.</p>

</div>
</div>
<div id="labeling" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Defining Home and Work Locations</h2>
<p>From the census data we have socioeconomic information for every geographical region in
each country and we used that to assign a Wealth Index value to them. A good proxy of
the demographic of the users can be obtained by the location of their home which we
can infeer from the recurrent stop locations we did in the previous chapter <a href="gps.html#stops">2.3</a>
given some regularity patterns and use the administrative information of the geometry where
it falls into. Moreover we can do this for every stops’ cluster. Our focus lies on the
home and the work locations as they’re likely to be the places where indiviuals spend more time
and define the largest bulk of their mobility patterns.</p>
<div id="seasonal-patterns" class="section level3" number="2.4.1">
<h3><span class="header-section-number">2.4.1</span> Seasonal patterns</h3>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:home-patterns"></span>
<img src="big-daa_files/figure-html/home-patterns-1.png" alt="Number of stops by weekday and start hour at home location" width="100%" />
<p class="caption">
Figure 2.2: Number of stops by weekday and start hour at home location
</p>
</div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:work-patterns"></span>
<img src="big-daa_files/figure-html/work-patterns-1.png" alt="Number of stops by weekday and start hour at work location" width="100%" />
<p class="caption">
Figure 2.3: Number of stops by weekday and start hour at work location
</p>
</div>
<p>As we can see from <a href="gps.html#fig:home-patterns">2.2</a> and <a href="gps.html#fig:work-patterns">2.3</a> usually a person’s mobility patterns have seasonal
structure so we label each stop with it’s corresponding day of the week. For this reason we need to label each stop with the
weekday value when it was created.</p>
</div>
<div id="code-1" class="section level3" number="2.4.2">
<h3><span class="header-section-number">2.4.2</span> Code</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="gps.html#cb10-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.withColumn(<span class="st">&quot;t_start_hour&quot;</span>, F.hour( F.to_timestamp(<span class="st">&quot;t_start&quot;</span>)))</span>
<span id="cb10-2"><a href="gps.html#cb10-2" aria-hidden="true" tabindex="-1"></a>        .withColumn(<span class="st">&quot;t_end_hour&quot;</span>, F.hour( F.to_timestamp(<span class="st">&quot;t_end&quot;</span>)))</span>
<span id="cb10-3"><a href="gps.html#cb10-3" aria-hidden="true" tabindex="-1"></a>        .withColumn(<span class="st">&#39;weekday&#39;</span>, F.dayofweek( F.to_timestamp(<span class="st">&quot;t_start&quot;</span>)))</span>
<span id="cb10-4"><a href="gps.html#cb10-4" aria-hidden="true" tabindex="-1"></a>        .withColumn(<span class="st">&quot;date&quot;</span>, F.to_timestamp(<span class="st">&quot;t_start&quot;</span>))</span>
<span id="cb10-5"><a href="gps.html#cb10-5" aria-hidden="true" tabindex="-1"></a>        .withColumn(<span class="st">&quot;date_trunc&quot;</span>, F.date_trunc(<span class="st">&quot;day&quot;</span>, F.col(<span class="st">&quot;date&quot;</span>)))</span></code></pre></div>
<p>Then we use the following function to label the home and work candidates. Notice that as this is a user defined
function, the schema at the top contains the output variables.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="gps.html#cb11-1" aria-hidden="true" tabindex="-1"></a>schema_df <span class="op">=</span> StructType([</span>
<span id="cb11-2"><a href="gps.html#cb11-2" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;user_id&#39;</span>, StringType(), <span class="va">False</span>),</span>
<span id="cb11-3"><a href="gps.html#cb11-3" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;t_start&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb11-4"><a href="gps.html#cb11-4" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;t_end&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb11-5"><a href="gps.html#cb11-5" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;duration&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb11-6"><a href="gps.html#cb11-6" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;lat&#39;</span>, DoubleType(), <span class="va">False</span>),</span>
<span id="cb11-7"><a href="gps.html#cb11-7" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;lon&#39;</span>, DoubleType(), <span class="va">False</span>),</span>
<span id="cb11-8"><a href="gps.html#cb11-8" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;total_duration_stop_location&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb11-9"><a href="gps.html#cb11-9" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;total_pings_stop&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb11-10"><a href="gps.html#cb11-10" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;cluster_label&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb11-11"><a href="gps.html#cb11-11" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;median_accuracy&#39;</span>, DoubleType(), <span class="va">False</span>),</span>
<span id="cb11-12"><a href="gps.html#cb11-12" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;location_type&#39;</span>, StringType(), <span class="va">True</span>),</span>
<span id="cb11-13"><a href="gps.html#cb11-13" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;home_label&#39;</span>, LongType(), <span class="va">True</span>),</span>
<span id="cb11-14"><a href="gps.html#cb11-14" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;work_label&#39;</span>, LongType(), <span class="va">True</span>),</span>
<span id="cb11-15"><a href="gps.html#cb11-15" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;geom_id&#39;</span>, StringType(), <span class="va">False</span>),</span>
<span id="cb11-16"><a href="gps.html#cb11-16" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;date&#39;</span>, TimestampType(), <span class="va">True</span>),</span>
<span id="cb11-17"><a href="gps.html#cb11-17" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;t_start_hour&#39;</span>, IntegerType(), <span class="va">True</span>),</span>
<span id="cb11-18"><a href="gps.html#cb11-18" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;t_end_hour&#39;</span>, IntegerType(), <span class="va">True</span>),</span>
<span id="cb11-19"><a href="gps.html#cb11-19" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&quot;date_trunc&quot;</span>, TimestampType(), <span class="va">True</span>)</span>
<span id="cb11-20"><a href="gps.html#cb11-20" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb11-21"><a href="gps.html#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="at">@pandas_udf</span>(schema_df, PandasUDFType.GROUPED_MAP)</span>
<span id="cb11-22"><a href="gps.html#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_home_work_label_dynamic(user_df, start_hour_day, end_hour_day, min_pings_home_cluster_label, work_activity_average):</span>
<span id="cb11-23"><a href="gps.html#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We start by assuming every cluster falls into the &quot;Other&quot; category.</span></span>
<span id="cb11-24"><a href="gps.html#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Meaning they&#39;re not home nor work.</span></span>
<span id="cb11-25"><a href="gps.html#cb11-25" aria-hidden="true" tabindex="-1"></a>    user_df[<span class="st">&#39;location_type&#39;</span>] <span class="op">=</span> <span class="st">&#39;O&#39;</span></span>
<span id="cb11-26"><a href="gps.html#cb11-26" aria-hidden="true" tabindex="-1"></a>    user_df[<span class="st">&#39;home_label&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb11-27"><a href="gps.html#cb11-27" aria-hidden="true" tabindex="-1"></a>    user_df[<span class="st">&#39;work_label&#39;</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb11-28"><a href="gps.html#cb11-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-29"><a href="gps.html#cb11-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># HOME</span></span>
<span id="cb11-30"><a href="gps.html#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># filter candidates as night-time stops</span></span>
<span id="cb11-31"><a href="gps.html#cb11-31" aria-hidden="true" tabindex="-1"></a>    home_tmp <span class="op">=</span> user_df[(user_df[<span class="st">&#39;t_start_hour&#39;</span>] <span class="op">&gt;=</span> end_hour_day) <span class="op">|</span> (</span>
<span id="cb11-32"><a href="gps.html#cb11-32" aria-hidden="true" tabindex="-1"></a>        user_df[<span class="st">&#39;t_end_hour&#39;</span>] <span class="op">&lt;=</span> start_hour_day)].copy()  <span class="co"># restrictive version of daytimes</span></span>
<span id="cb11-33"><a href="gps.html#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="gps.html#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> home_tmp.empty:  <span class="co"># if we don&#39;t have at least a home location, we return and not attemp to compute work location</span></span>
<span id="cb11-35"><a href="gps.html#cb11-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> remove_unused_cols(user_df)</span>
<span id="cb11-36"><a href="gps.html#cb11-36" aria-hidden="true" tabindex="-1"></a>    first_day <span class="op">=</span> home_tmp[<span class="st">&#39;date_trunc&#39;</span>].<span class="bu">min</span>()</span>
<span id="cb11-37"><a href="gps.html#cb11-37" aria-hidden="true" tabindex="-1"></a>    last_day <span class="op">=</span> home_tmp[<span class="st">&#39;date_trunc&#39;</span>].<span class="bu">max</span>()</span>
<span id="cb11-38"><a href="gps.html#cb11-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-39"><a href="gps.html#cb11-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># work on clusters with &quot;duration&quot; attribute per day (&quot;date_trunc&quot;)</span></span>
<span id="cb11-40"><a href="gps.html#cb11-40" aria-hidden="true" tabindex="-1"></a>    home_tmp <span class="op">=</span> home_tmp[[<span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;duration&#39;</span>, <span class="st">&#39;total_pings_stop&#39;</span>]].groupby(</span>
<span id="cb11-41"><a href="gps.html#cb11-41" aria-hidden="true" tabindex="-1"></a>        [<span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>]).<span class="bu">sum</span>().reset_index().sort_values(<span class="st">&#39;date_trunc&#39;</span>)</span>
<span id="cb11-42"><a href="gps.html#cb11-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># computer cumulative duration of candidates over &quot;period&quot; window</span></span>
<span id="cb11-43"><a href="gps.html#cb11-43" aria-hidden="true" tabindex="-1"></a>    home_tmp <span class="op">=</span> home_tmp.merge(home_tmp[[<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;duration&#39;</span>, <span class="st">&#39;total_pings_stop&#39;</span>]].groupby(</span>
<span id="cb11-44"><a href="gps.html#cb11-44" aria-hidden="true" tabindex="-1"></a>        [<span class="st">&#39;cluster_label&#39;</span>]).<span class="bu">apply</span>(home_rolling_on_date).reset_index(), on<span class="op">=</span>[<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;cluster_label&#39;</span>], suffixes<span class="op">=</span>(<span class="st">&#39;&#39;</span>, <span class="st">&#39;_cum&#39;</span>))</span>
<span id="cb11-45"><a href="gps.html#cb11-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(home_tmp.columns)</span>
<span id="cb11-46"><a href="gps.html#cb11-46" aria-hidden="true" tabindex="-1"></a><span class="co">######</span></span>
<span id="cb11-47"><a href="gps.html#cb11-47" aria-hidden="true" tabindex="-1"></a>    home_tmp <span class="op">=</span> home_tmp[home_tmp.total_pings_stop_cum <span class="op">&gt;</span></span>
<span id="cb11-48"><a href="gps.html#cb11-48" aria-hidden="true" tabindex="-1"></a>                        min_pings_home_cluster_label].drop(<span class="st">&#39;total_pings_stop_cum&#39;</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb11-49"><a href="gps.html#cb11-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-50"><a href="gps.html#cb11-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># filter out nan rows, equivalent to filter on min_days</span></span>
<span id="cb11-51"><a href="gps.html#cb11-51" aria-hidden="true" tabindex="-1"></a>    home_tmp <span class="op">=</span> home_tmp.dropna(subset<span class="op">=</span>[<span class="st">&#39;duration_cum&#39;</span>])</span>
<span id="cb11-52"><a href="gps.html#cb11-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-53"><a href="gps.html#cb11-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> home_tmp.empty:  <span class="co"># if we don&#39;t have at least a home location, we return and not attemp to compute work location</span></span>
<span id="cb11-54"><a href="gps.html#cb11-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> remove_unused_cols(user_df)</span>
<span id="cb11-55"><a href="gps.html#cb11-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-56"><a href="gps.html#cb11-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">#####################</span></span>
<span id="cb11-57"><a href="gps.html#cb11-57" aria-hidden="true" tabindex="-1"></a>    date_cluster <span class="op">=</span> home_tmp.drop_duplicates([<span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>])[</span>
<span id="cb11-58"><a href="gps.html#cb11-58" aria-hidden="true" tabindex="-1"></a>        [<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;cluster_label&#39;</span>]].copy()</span>
<span id="cb11-59"><a href="gps.html#cb11-59" aria-hidden="true" tabindex="-1"></a>    date_cluster <span class="op">=</span> date_cluster.drop_duplicates([<span class="st">&#39;date_trunc&#39;</span>])</span>
<span id="cb11-60"><a href="gps.html#cb11-60" aria-hidden="true" tabindex="-1"></a>    home_label <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(date_cluster.cluster_label, date_cluster.date_trunc))</span>
<span id="cb11-61"><a href="gps.html#cb11-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># creating a multinidex over which locating tuples of &quot;date_trunc&quot; and &quot;home_label&quot;</span></span>
<span id="cb11-62"><a href="gps.html#cb11-62" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> pd.MultiIndex.from_frame(user_df[[<span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>]])</span>
<span id="cb11-63"><a href="gps.html#cb11-63" aria-hidden="true" tabindex="-1"></a>    user_df.loc[idx.isin(home_label), <span class="st">&#39;home_label&#39;</span>] <span class="op">=</span> user_df.loc[idx.isin(</span>
<span id="cb11-64"><a href="gps.html#cb11-64" aria-hidden="true" tabindex="-1"></a>        home_label), <span class="st">&#39;cluster_label&#39;</span>]</span>
<span id="cb11-65"><a href="gps.html#cb11-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">#####################</span></span>
<span id="cb11-66"><a href="gps.html#cb11-66" aria-hidden="true" tabindex="-1"></a>    base_dates <span class="op">=</span> pd.date_range(start<span class="op">=</span>first_day, end<span class="op">=</span>last_day)</span>
<span id="cb11-67"><a href="gps.html#cb11-67" aria-hidden="true" tabindex="-1"></a>    date_cluster <span class="op">=</span> date_cluster.sort_values(</span>
<span id="cb11-68"><a href="gps.html#cb11-68" aria-hidden="true" tabindex="-1"></a>        by<span class="op">=</span><span class="st">&#39;date_trunc&#39;</span>).set_index(<span class="st">&#39;date_trunc&#39;</span>)</span>
<span id="cb11-69"><a href="gps.html#cb11-69" aria-hidden="true" tabindex="-1"></a>    date_cluster <span class="op">=</span> date_cluster.reindex(base_dates)</span>
<span id="cb11-70"><a href="gps.html#cb11-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pd.notna(date_cluster[<span class="st">&#39;cluster_label&#39;</span>]).<span class="bu">sum</span>() <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb11-71"><a href="gps.html#cb11-71" aria-hidden="true" tabindex="-1"></a>        date_cluster <span class="op">=</span> date_cluster.interpolate(</span>
<span id="cb11-72"><a href="gps.html#cb11-72" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">&#39;nearest&#39;</span>).ffill().bfill()</span>
<span id="cb11-73"><a href="gps.html#cb11-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb11-74"><a href="gps.html#cb11-74" aria-hidden="true" tabindex="-1"></a>        date_cluster <span class="op">=</span> date_cluster.ffill().bfill()</span>
<span id="cb11-75"><a href="gps.html#cb11-75" aria-hidden="true" tabindex="-1"></a>    date_cluster.index.name <span class="op">=</span> <span class="st">&#39;date_trunc&#39;</span></span>
<span id="cb11-76"><a href="gps.html#cb11-76" aria-hidden="true" tabindex="-1"></a>    date_cluster <span class="op">=</span> date_cluster.reset_index()</span>
<span id="cb11-77"><a href="gps.html#cb11-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-78"><a href="gps.html#cb11-78" aria-hidden="true" tabindex="-1"></a>    home_label <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(date_cluster.cluster_label, date_cluster.date_trunc))</span>
<span id="cb11-79"><a href="gps.html#cb11-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># creating a multindex over which locating tuples of &quot;date_trunc&quot; and &quot;home_label&quot;</span></span>
<span id="cb11-80"><a href="gps.html#cb11-80" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> pd.MultiIndex.from_frame(user_df[[<span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>]])</span>
<span id="cb11-81"><a href="gps.html#cb11-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-82"><a href="gps.html#cb11-82" aria-hidden="true" tabindex="-1"></a>    user_df.loc[idx.isin(home_label), <span class="st">&#39;location_type&#39;</span>] <span class="op">=</span> <span class="st">&#39;H&#39;</span></span>
<span id="cb11-83"><a href="gps.html#cb11-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-84"><a href="gps.html#cb11-84" aria-hidden="true" tabindex="-1"></a>    home_list <span class="op">=</span> home_tmp.cluster_label.unique()</span>
<span id="cb11-85"><a href="gps.html#cb11-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> home_list.size <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-86"><a href="gps.html#cb11-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> remove_unused_cols(user_df)</span>
<span id="cb11-87"><a href="gps.html#cb11-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-88"><a href="gps.html#cb11-88" aria-hidden="true" tabindex="-1"></a>    <span class="co">########</span></span>
<span id="cb11-89"><a href="gps.html#cb11-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># WORK #</span></span>
<span id="cb11-90"><a href="gps.html#cb11-90" aria-hidden="true" tabindex="-1"></a>    <span class="co">########</span></span>
<span id="cb11-91"><a href="gps.html#cb11-91" aria-hidden="true" tabindex="-1"></a>    work_tmp <span class="op">=</span> user_df[<span class="op">~</span>(user_df[<span class="st">&#39;cluster_label&#39;</span>].isin(home_list))].copy()</span>
<span id="cb11-92"><a href="gps.html#cb11-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> work_tmp.empty:  <span class="co"># if we can&#39;t compute work location we return</span></span>
<span id="cb11-93"><a href="gps.html#cb11-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> remove_unused_cols(user_df)</span>
<span id="cb11-94"><a href="gps.html#cb11-94" aria-hidden="true" tabindex="-1"></a><span class="co">#   if daytime: ######don&#39;t like it</span></span>
<span id="cb11-95"><a href="gps.html#cb11-95" aria-hidden="true" tabindex="-1"></a>    work_tmp <span class="op">=</span> work_tmp[((work_tmp[<span class="st">&#39;t_start_hour&#39;</span>] <span class="op">&gt;=</span> start_hour_day<span class="op">+</span><span class="dv">4</span>) <span class="op">&amp;</span> (work_tmp[<span class="st">&#39;t_end_hour&#39;</span>]</span>
<span id="cb11-96"><a href="gps.html#cb11-96" aria-hidden="true" tabindex="-1"></a>                                                                             <span class="op">&lt;=</span> end_hour_day<span class="op">-</span><span class="dv">6</span>)) <span class="op">&amp;</span> (<span class="op">~</span>work_tmp[<span class="st">&#39;weekday&#39;</span>].isin([<span class="dv">1</span>, <span class="dv">7</span>]))]  <span class="co"># restrictive version of daytimes</span></span>
<span id="cb11-97"><a href="gps.html#cb11-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-98"><a href="gps.html#cb11-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> work_tmp.empty:  <span class="co"># if we can&#39;t compute work location we return</span></span>
<span id="cb11-99"><a href="gps.html#cb11-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> remove_unused_cols(user_df)</span>
<span id="cb11-100"><a href="gps.html#cb11-100" aria-hidden="true" tabindex="-1"></a>    first_day <span class="op">=</span> work_tmp[<span class="st">&#39;date_trunc&#39;</span>].<span class="bu">min</span>()</span>
<span id="cb11-101"><a href="gps.html#cb11-101" aria-hidden="true" tabindex="-1"></a>    <span class="co"># drop duplicates, smooth over &quot;period&quot; time window</span></span>
<span id="cb11-102"><a href="gps.html#cb11-102" aria-hidden="true" tabindex="-1"></a>    work_tmp <span class="op">=</span> work_tmp[[<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;duration&#39;</span>]].groupby(</span>
<span id="cb11-103"><a href="gps.html#cb11-103" aria-hidden="true" tabindex="-1"></a>        [<span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>]).<span class="bu">sum</span>().reset_index()</span>
<span id="cb11-104"><a href="gps.html#cb11-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-105"><a href="gps.html#cb11-105" aria-hidden="true" tabindex="-1"></a>    work_tmp <span class="op">=</span> work_tmp.merge(work_tmp[[<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;duration&#39;</span>]]</span>
<span id="cb11-106"><a href="gps.html#cb11-106" aria-hidden="true" tabindex="-1"></a>                              .groupby([<span class="st">&#39;cluster_label&#39;</span>])</span>
<span id="cb11-107"><a href="gps.html#cb11-107" aria-hidden="true" tabindex="-1"></a>                              .<span class="bu">apply</span>(work_rolling_on_date)</span>
<span id="cb11-108"><a href="gps.html#cb11-108" aria-hidden="true" tabindex="-1"></a>                              .reset_index(), on<span class="op">=</span>[<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;cluster_label&#39;</span>], suffixes<span class="op">=</span>(<span class="st">&#39;&#39;</span>, <span class="st">&#39;_average&#39;</span>))</span>
<span id="cb11-109"><a href="gps.html#cb11-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-110"><a href="gps.html#cb11-110" aria-hidden="true" tabindex="-1"></a>    <span class="co"># filter out candidates which on average on the period do not pass the constraint</span></span>
<span id="cb11-111"><a href="gps.html#cb11-111" aria-hidden="true" tabindex="-1"></a>    work_tmp <span class="op">=</span> work_tmp[(work_tmp.duration_average <span class="op">&gt;=</span> work_activity_average)]</span>
<span id="cb11-112"><a href="gps.html#cb11-112" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Select work clusters candidate: the clusters that passed the previous criteria are selected as work for the day</span></span>
<span id="cb11-113"><a href="gps.html#cb11-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> work_tmp.empty:  <span class="co"># if we can&#39;t compute work location we return</span></span>
<span id="cb11-114"><a href="gps.html#cb11-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> remove_unused_cols(user_df)</span>
<span id="cb11-115"><a href="gps.html#cb11-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-116"><a href="gps.html#cb11-116" aria-hidden="true" tabindex="-1"></a>    <span class="co">#####################</span></span>
<span id="cb11-117"><a href="gps.html#cb11-117" aria-hidden="true" tabindex="-1"></a>    work_label <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(work_tmp.cluster_label, work_tmp.date_trunc))</span>
<span id="cb11-118"><a href="gps.html#cb11-118" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> pd.MultiIndex.from_frame(user_df[[<span class="st">&#39;cluster_label&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>]])</span>
<span id="cb11-119"><a href="gps.html#cb11-119" aria-hidden="true" tabindex="-1"></a>    work_list <span class="op">=</span> work_tmp.cluster_label.unique()</span>
<span id="cb11-120"><a href="gps.html#cb11-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> work_list.size <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-121"><a href="gps.html#cb11-121" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> remove_unused_cols(user_df)</span>
<span id="cb11-122"><a href="gps.html#cb11-122" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add cluster label to work_label on the day on which it is found to be work_location only</span></span>
<span id="cb11-123"><a href="gps.html#cb11-123" aria-hidden="true" tabindex="-1"></a>    user_df.loc[idx.isin(work_label), <span class="st">&#39;work_label&#39;</span>] <span class="op">=</span> user_df.loc[idx.isin(</span>
<span id="cb11-124"><a href="gps.html#cb11-124" aria-hidden="true" tabindex="-1"></a>        work_label), <span class="st">&#39;cluster_label&#39;</span>]</span>
<span id="cb11-125"><a href="gps.html#cb11-125" aria-hidden="true" tabindex="-1"></a>    <span class="co">#####################</span></span>
<span id="cb11-126"><a href="gps.html#cb11-126" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add work labels to all user dataset</span></span>
<span id="cb11-127"><a href="gps.html#cb11-127" aria-hidden="true" tabindex="-1"></a>    work_label <span class="op">=</span> work_tmp[<span class="st">&#39;cluster_label&#39;</span>].unique()</span>
<span id="cb11-128"><a href="gps.html#cb11-128" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> pd.Index(user_df[<span class="st">&#39;cluster_label&#39;</span>])</span>
<span id="cb11-129"><a href="gps.html#cb11-129" aria-hidden="true" tabindex="-1"></a>    user_df.loc[idx.isin(work_label), <span class="st">&#39;location_type&#39;</span>] <span class="op">=</span> <span class="st">&#39;W&#39;</span></span>
<span id="cb11-130"><a href="gps.html#cb11-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-131"><a href="gps.html#cb11-131" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> remove_unused_cols(user_df)</span></code></pre></div>

</div>
</div>
<div id="mobility" class="section level2" number="2.5">
<h2><span class="header-section-number">2.5</span> Mobility Patterns</h2>
<p>Individual mobility analysis represent a key ingredient to understand and timely follow changes in their behavioural patterns. In this book we relie on heavily tested and robust GPS traces preprocessing to measure and quantify individual mobility patterns.</p>
<div id="socio-economic-groups" class="section level3" number="2.5.1">
<h3><span class="header-section-number">2.5.1</span> Socio-economic groups</h3>
<p>Particular attention is devoted to different socio-economig groups. Groups are assigned to individuals based on the administrative unit where their principal pre-pandemic home-location is detected. Three main socio-economic groups are analysed here: the 40% with lowest index value (the 0% to 40% administrative units with lowest wealth index value), the middle ones (from 40% to 80%), and the top 20% (the wealthiest 80 to 100 percentiles).
Socio-economic groups are drawn both by considering the entire country wealth index percentiles and by considering percentiles relatively to the metropolitan area administrative units are part of.</p>
<p>The computation is performed by loading and grouping administrative information “admin.csv” files for each country using pyspark.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="gps.html#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_admin(country,admin_path):</span>
<span id="cb12-2"><a href="gps.html#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb12-3"><a href="gps.html#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">  INPUT:  country ISO code, path to the admin files (saved as &quot;{country}/admin.csv&quot; files)</span></span>
<span id="cb12-4"><a href="gps.html#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">  OUTPUT: three pandas dataframes</span></span>
<span id="cb12-5"><a href="gps.html#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">          - &quot;admins_by_country&quot;: all country administrative units with socio-economic group assigned based on entire country</span></span>
<span id="cb12-6"><a href="gps.html#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">          - &quot;admins_by_metro_area&quot;: wealth groups computed relatively to the emtropolitan area of each unit</span></span>
<span id="cb12-7"><a href="gps.html#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">          - total population of the metropolitan areas</span></span>
<span id="cb12-8"><a href="gps.html#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">  &#39;&#39;&#39;</span></span>
<span id="cb12-9"><a href="gps.html#cb12-9" aria-hidden="true" tabindex="-1"></a>  cols <span class="op">=</span> [<span class="st">&#39;geom_id&#39;</span>, <span class="st">&#39;metro_area_name&#39;</span>, <span class="st">&#39;pop&#39;</span>, <span class="st">&#39;wealth_index&#39;</span>]</span>
<span id="cb12-10"><a href="gps.html#cb12-10" aria-hidden="true" tabindex="-1"></a>  admin <span class="op">=</span> spark.read.option(<span class="st">&#39;header&#39;</span>, <span class="st">&#39;true&#39;</span>).csv(admin_path<span class="op">+</span><span class="ss">f&#39;</span><span class="sc">{</span>country<span class="sc">}</span><span class="ss">/admin.csv&#39;</span>).toPandas()</span>
<span id="cb12-11"><a href="gps.html#cb12-11" aria-hidden="true" tabindex="-1"></a>  admins <span class="op">=</span> admins[[cols]]</span>
<span id="cb12-12"><a href="gps.html#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="gps.html#cb12-13" aria-hidden="true" tabindex="-1"></a>  admins <span class="op">=</span> admins.rename(columns<span class="op">=</span>{<span class="st">&#39;metro_ar_1&#39;</span>: <span class="st">&#39;metro_area_name&#39;</span>, <span class="st">&#39;wealth_ind&#39;</span>: <span class="st">&#39;wealth_index&#39;</span>})</span>
<span id="cb12-14"><a href="gps.html#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="gps.html#cb12-15" aria-hidden="true" tabindex="-1"></a>  admins_by_country <span class="op">=</span> admins[[<span class="st">&#39;geom_id&#39;</span>, <span class="st">&#39;pop&#39;</span>, <span class="st">&#39;wealth_index&#39;</span>]].dropna(</span>
<span id="cb12-16"><a href="gps.html#cb12-16" aria-hidden="true" tabindex="-1"></a>  ).sort_values(by<span class="op">=</span>[<span class="st">&#39;wealth_index&#39;</span>], ascending<span class="op">=</span>[<span class="va">False</span>]).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-17"><a href="gps.html#cb12-17" aria-hidden="true" tabindex="-1"></a>  admins_by_country[<span class="st">&#39;pct_wealth&#39;</span>] <span class="op">=</span> admins_by_country[<span class="st">&#39;pop&#39;</span>].cumsum().divide(</span>
<span id="cb12-18"><a href="gps.html#cb12-18" aria-hidden="true" tabindex="-1"></a>      admins_by_country[<span class="st">&#39;pop&#39;</span>].<span class="bu">sum</span>())</span>
<span id="cb12-19"><a href="gps.html#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="gps.html#cb12-20" aria-hidden="true" tabindex="-1"></a>  admins_by_metro_area <span class="op">=</span> admins[[<span class="st">&#39;geom_id&#39;</span>, <span class="st">&#39;metro_area_name&#39;</span>, <span class="st">&#39;pop&#39;</span>, <span class="st">&#39;wealth_index&#39;</span>]].dropna(</span>
<span id="cb12-21"><a href="gps.html#cb12-21" aria-hidden="true" tabindex="-1"></a>  ).sort_values(by<span class="op">=</span>[<span class="st">&#39;metro_area_name&#39;</span>, <span class="st">&#39;wealth_index&#39;</span>], ascending<span class="op">=</span>[<span class="va">True</span>, <span class="va">False</span>]).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-22"><a href="gps.html#cb12-22" aria-hidden="true" tabindex="-1"></a>  admins_by_metro_area[<span class="st">&#39;pct_wealth&#39;</span>] <span class="op">=</span> admins_by_metro_area.groupby(</span>
<span id="cb12-23"><a href="gps.html#cb12-23" aria-hidden="true" tabindex="-1"></a>      <span class="st">&#39;metro_area_name&#39;</span>)[<span class="st">&#39;pop&#39;</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: x.cumsum()<span class="op">/</span>x.<span class="bu">sum</span>())</span>
<span id="cb12-24"><a href="gps.html#cb12-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-25"><a href="gps.html#cb12-25" aria-hidden="true" tabindex="-1"></a>  pop_metro_areas <span class="op">=</span> admins_by_metro_area.groupby(</span>
<span id="cb12-26"><a href="gps.html#cb12-26" aria-hidden="true" tabindex="-1"></a>      <span class="st">&#39;metro_area_name&#39;</span>)[<span class="st">&#39;pop&#39;</span>].<span class="bu">sum</span>().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb12-27"><a href="gps.html#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="gps.html#cb12-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> admins_by_country, admins_by_metro_area, pop_metro_areas</span></code></pre></div>
</div>
<div id="selection" class="section level3" number="2.5.2">
<h3><span class="header-section-number">2.5.2</span> Individual’s selection</h3>
<p>Following the preprocessing pipeline description presented in the previous sections of the book, here we introduce an additional step aiming at refinining the pool of individuals analysed. Our intent is to measure mobility patterns only for individuals whose activity level is sufficiently high to ensure a minimum level of representativeness of the data. Individuals with recods over only a small number of days cannot be considered as a complete and correct representation fairly proxying the mobility features of an individual.</p>
<p>To this extent we use the duration of each individuals records, which have been computed during the pipeline run.
The selection imposes two requirements on individuals: i) each individual should be active (i.e. should have at least one stop record) for a minimum number of days during the pre-pandemic period (which is choose to run from the beginning of January 2020 until March 15, 2020; ii) each individual should be active for a minimum fraction of days after the pre-pandemic period until the end of 2020. This selection process is obtained invoking the following python function which returns a list of the users to be included during the analyses.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="gps.html#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_active_list(durations, country, activity_level):</span>
<span id="cb13-2"><a href="gps.html#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb13-3"><a href="gps.html#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">  For each country invoke the following function to get a list of all active individuals.</span></span>
<span id="cb13-4"><a href="gps.html#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">    INPUT: spark dataframe with precomputed individual stops&#39; durations; country ISO code; minimum activity level required</span></span>
<span id="cb13-5"><a href="gps.html#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">    OUTPUT: list of active individuals &quot;user_id&quot;</span></span>
<span id="cb13-6"><a href="gps.html#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">  &#39;&#39;&#39;</span></span>
<span id="cb13-7"><a href="gps.html#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="gps.html#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Indonesia experiences a major dropout from the service during January 2020. For this reason, a specific pre-pandemic period was adopted</span></span>
<span id="cb13-9"><a href="gps.html#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> country <span class="op">==</span> <span class="st">&#39;ID&#39;</span>:</span>
<span id="cb13-10"><a href="gps.html#cb13-10" aria-hidden="true" tabindex="-1"></a>      durations_2 <span class="op">=</span> durations.where(col(<span class="st">&#39;date_trunc&#39;</span>) <span class="op">&gt;=</span> <span class="st">&#39;2020-02-01&#39;</span>)</span>
<span id="cb13-11"><a href="gps.html#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb13-12"><a href="gps.html#cb13-12" aria-hidden="true" tabindex="-1"></a>      durations_2 <span class="op">=</span> durations</span>
<span id="cb13-13"><a href="gps.html#cb13-13" aria-hidden="true" tabindex="-1"></a>  durations_2 <span class="op">=</span> durations_2.where(col(<span class="st">&#39;date_trunc&#39;</span>) <span class="op">&lt;</span> <span class="st">&#39;2021-01-01&#39;</span>)</span>
<span id="cb13-14"><a href="gps.html#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="gps.html#cb13-15" aria-hidden="true" tabindex="-1"></a>  active_days <span class="op">=</span> (durations_2</span>
<span id="cb13-16"><a href="gps.html#cb13-16" aria-hidden="true" tabindex="-1"></a>                 .withColumn(<span class="st">&#39;pandemic&#39;</span>, F.when(col(<span class="st">&#39;date_trunc&#39;</span>) <span class="op">&lt;</span> <span class="st">&#39;2020-03-15&#39;</span>, <span class="st">&#39;pre&#39;</span>).otherwise(<span class="st">&#39;post&#39;</span>))</span>
<span id="cb13-17"><a href="gps.html#cb13-17" aria-hidden="true" tabindex="-1"></a>                 .groupby(<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;pandemic&#39;</span>)</span>
<span id="cb13-18"><a href="gps.html#cb13-18" aria-hidden="true" tabindex="-1"></a>                 .agg(F.countDistinct(<span class="st">&#39;date_trunc&#39;</span>).alias(<span class="st">&#39;n_days&#39;</span>)))</span>
<span id="cb13-19"><a href="gps.html#cb13-19" aria-hidden="true" tabindex="-1"></a>  active_days.cache()</span>
<span id="cb13-20"><a href="gps.html#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="gps.html#cb13-21" aria-hidden="true" tabindex="-1"></a>  max_days_pre <span class="op">=</span> (active_days</span>
<span id="cb13-22"><a href="gps.html#cb13-22" aria-hidden="true" tabindex="-1"></a>                  .where(col(<span class="st">&#39;pandemic&#39;</span>) <span class="op">==</span> <span class="st">&#39;pre&#39;</span>)</span>
<span id="cb13-23"><a href="gps.html#cb13-23" aria-hidden="true" tabindex="-1"></a>                  .agg(F.<span class="bu">max</span>(<span class="st">&#39;n_days&#39;</span>).alias(<span class="st">&#39;max_days_pre&#39;</span>))</span>
<span id="cb13-24"><a href="gps.html#cb13-24" aria-hidden="true" tabindex="-1"></a>                  .toPandas().loc[<span class="dv">0</span>, <span class="st">&#39;max_days_pre&#39;</span>])</span>
<span id="cb13-25"><a href="gps.html#cb13-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-26"><a href="gps.html#cb13-26" aria-hidden="true" tabindex="-1"></a>  max_days_all <span class="op">=</span> (active_days</span>
<span id="cb13-27"><a href="gps.html#cb13-27" aria-hidden="true" tabindex="-1"></a>                  .groupby(<span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb13-28"><a href="gps.html#cb13-28" aria-hidden="true" tabindex="-1"></a>                  .agg(F.<span class="bu">sum</span>(<span class="st">&#39;n_days&#39;</span>).alias(<span class="st">&#39;n_days&#39;</span>))</span>
<span id="cb13-29"><a href="gps.html#cb13-29" aria-hidden="true" tabindex="-1"></a>                  .agg(F.<span class="bu">max</span>(<span class="st">&#39;n_days&#39;</span>).alias(<span class="st">&#39;max_days_all&#39;</span>))</span>
<span id="cb13-30"><a href="gps.html#cb13-30" aria-hidden="true" tabindex="-1"></a>                  .toPandas().loc[<span class="dv">0</span>, <span class="st">&#39;max_days_all&#39;</span>])</span>
<span id="cb13-31"><a href="gps.html#cb13-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-32"><a href="gps.html#cb13-32" aria-hidden="true" tabindex="-1"></a>  active_users <span class="op">=</span> (active_days</span>
<span id="cb13-33"><a href="gps.html#cb13-33" aria-hidden="true" tabindex="-1"></a>                  .groupby(<span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb13-34"><a href="gps.html#cb13-34" aria-hidden="true" tabindex="-1"></a>                  .pivot(<span class="st">&#39;pandemic&#39;</span>)</span>
<span id="cb13-35"><a href="gps.html#cb13-35" aria-hidden="true" tabindex="-1"></a>                  .agg(F.first(<span class="st">&#39;n_days&#39;</span>))</span>
<span id="cb13-36"><a href="gps.html#cb13-36" aria-hidden="true" tabindex="-1"></a>                  .fillna(<span class="dv">0</span>)</span>
<span id="cb13-37"><a href="gps.html#cb13-37" aria-hidden="true" tabindex="-1"></a>                  .withColumn(<span class="st">&#39;tot&#39;</span>, col(<span class="st">&#39;pre&#39;</span>)<span class="op">+</span>col(<span class="st">&#39;post&#39;</span>))</span>
<span id="cb13-38"><a href="gps.html#cb13-38" aria-hidden="true" tabindex="-1"></a>                  .where(col(<span class="st">&#39;pre&#39;</span>) <span class="op">&gt;=</span> activity_level<span class="op">*</span>max_days_pre)</span>
<span id="cb13-39"><a href="gps.html#cb13-39" aria-hidden="true" tabindex="-1"></a>                  .where(col(<span class="st">&#39;tot&#39;</span>) <span class="op">&gt;=</span> activity_level<span class="op">*</span>max_days_all))</span>
<span id="cb13-40"><a href="gps.html#cb13-40" aria-hidden="true" tabindex="-1"></a>  active_days.unpersist()</span>
<span id="cb13-41"><a href="gps.html#cb13-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-42"><a href="gps.html#cb13-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> active_users</span></code></pre></div>
</div>
<div id="measures" class="section level3" number="2.5.3">
<h3><span class="header-section-number">2.5.3</span> Measures</h3>
<p>The focus on socio-economic groups require an aggregation process which is performed for each individuals based on their home-location administrative unit. Both stop-locations and duration data processed during the pipeline run are used here.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="gps.html#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_durations_and_admins(country, data_date, stop_path, activity_level<span class="op">=</span><span class="dv">0</span>, hw<span class="op">=</span><span class="dv">28</span>, ww<span class="op">=</span><span class="dv">28</span>, wa<span class="op">=</span><span class="dv">900</span>, mph<span class="op">=</span><span class="dv">10</span>, mpw<span class="op">=</span><span class="dv">7</span>):</span>
<span id="cb14-2"><a href="gps.html#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb14-3"><a href="gps.html#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">  INPUT: country ISO code, date of the data to consider, path to the stop locations data,</span></span>
<span id="cb14-4"><a href="gps.html#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">         minimum activity level for individuals to be included, **{pipeline computation specific parameters}</span></span>
<span id="cb14-5"><a href="gps.html#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">  OUTPUT: spark dataframe containing &quot;date&quot; (with daily frequency), &quot;user_id&quot;, &quot;H&quot; (time spent at home), &quot;W&quot; (time spent at work),</span></span>
<span id="cb14-6"><a href="gps.html#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">          &quot;R&quot; (1 if not leaving home), &quot;C&quot; (1 if commuting to work), &quot;O&quot; (time spent in locations which are neither home nor work)</span></span>
<span id="cb14-7"><a href="gps.html#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">  &#39;&#39;&#39;</span></span>
<span id="cb14-8"><a href="gps.html#cb14-8" aria-hidden="true" tabindex="-1"></a>  personal_nf <span class="op">=</span> <span class="ss">f&quot;personal_stop_location_hw</span><span class="sc">{hw}</span><span class="ss">_ww</span><span class="sc">{ww}</span><span class="ss">_wa</span><span class="sc">{wa}</span><span class="ss">_mph</span><span class="sc">{</span>mph<span class="sc">}</span><span class="ss">_mpw</span><span class="sc">{</span>mpw<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb14-9"><a href="gps.html#cb14-9" aria-hidden="true" tabindex="-1"></a>  stops <span class="op">=</span> spark.read.parquet(<span class="ss">f&quot;</span><span class="sc">{</span>stop_path<span class="sc">}{</span>country<span class="sc">}</span><span class="ss">/accuracy100_maxtimestop3600_staytime300_radius50_dbscanradius50/date</span><span class="sc">{</span>data_date<span class="sc">}</span><span class="ss">/&quot;</span> <span class="op">+</span> personal_nf)</span>
<span id="cb14-10"><a href="gps.html#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="gps.html#cb14-11" aria-hidden="true" tabindex="-1"></a>  fname_nf <span class="op">=</span> <span class="ss">f&#39;durations_window_hw</span><span class="sc">{hw}</span><span class="ss">_ww</span><span class="sc">{ww}</span><span class="ss">_wa</span><span class="sc">{wa}</span><span class="ss">_mph</span><span class="sc">{</span>mph<span class="sc">}</span><span class="ss">_mpw</span><span class="sc">{</span>mpw<span class="sc">}</span><span class="ss">&#39;</span></span>
<span id="cb14-12"><a href="gps.html#cb14-12" aria-hidden="true" tabindex="-1"></a>  durations_path_nf <span class="op">=</span> <span class="ss">f&#39;</span><span class="sc">{</span>stop_path<span class="sc">}{</span>country<span class="sc">}</span><span class="ss">/accuracy100_maxtimestop3600_staytime300_radius50_dbscanradius50/date</span><span class="sc">{</span>data_date<span class="sc">}</span><span class="ss">/&#39;</span> <span class="op">+</span> fname_nf</span>
<span id="cb14-13"><a href="gps.html#cb14-13" aria-hidden="true" tabindex="-1"></a>  durations <span class="op">=</span> spark.read.parquet(durations_path_nf)</span>
<span id="cb14-14"><a href="gps.html#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="gps.html#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># aggregate day/night</span></span>
<span id="cb14-16"><a href="gps.html#cb14-16" aria-hidden="true" tabindex="-1"></a>  durations <span class="op">=</span> (durations</span>
<span id="cb14-17"><a href="gps.html#cb14-17" aria-hidden="true" tabindex="-1"></a>               .groupby(<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb14-18"><a href="gps.html#cb14-18" aria-hidden="true" tabindex="-1"></a>               .agg(F.<span class="bu">sum</span>(<span class="st">&#39;H&#39;</span>).alias(<span class="st">&#39;H&#39;</span>),</span>
<span id="cb14-19"><a href="gps.html#cb14-19" aria-hidden="true" tabindex="-1"></a>                    F.<span class="bu">sum</span>(<span class="st">&#39;W&#39;</span>).alias(<span class="st">&#39;W&#39;</span>),</span>
<span id="cb14-20"><a href="gps.html#cb14-20" aria-hidden="true" tabindex="-1"></a>                    F.<span class="bu">sum</span>(<span class="st">&#39;O&#39;</span>).alias(<span class="st">&#39;O&#39;</span>)))</span>
<span id="cb14-21"><a href="gps.html#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="gps.html#cb14-22" aria-hidden="true" tabindex="-1"></a>  active_users <span class="op">=</span> get_active_list(durations, country, activity_level)</span>
<span id="cb14-23"><a href="gps.html#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="gps.html#cb14-24" aria-hidden="true" tabindex="-1"></a>  durations <span class="op">=</span> durations.join(active_users.select(</span>
<span id="cb14-25"><a href="gps.html#cb14-25" aria-hidden="true" tabindex="-1"></a>      <span class="st">&#39;user_id&#39;</span>), on<span class="op">=</span><span class="st">&#39;user_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>)</span>
<span id="cb14-26"><a href="gps.html#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="gps.html#cb14-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># create binary column for commuters</span></span>
<span id="cb14-28"><a href="gps.html#cb14-28" aria-hidden="true" tabindex="-1"></a>  durations <span class="op">=</span> durations.withColumn(</span>
<span id="cb14-29"><a href="gps.html#cb14-29" aria-hidden="true" tabindex="-1"></a>      <span class="st">&#39;C&#39;</span>, F.when(col(<span class="st">&#39;W&#39;</span>).isNull(), <span class="dv">0</span>).otherwise(<span class="dv">1</span>))</span>
<span id="cb14-30"><a href="gps.html#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="gps.html#cb14-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># create binary column for people who don&#39;t leave home, aka recluse</span></span>
<span id="cb14-32"><a href="gps.html#cb14-32" aria-hidden="true" tabindex="-1"></a>  durations <span class="op">=</span> durations.withColumn(<span class="st">&#39;R&#39;</span>, F.when(</span>
<span id="cb14-33"><a href="gps.html#cb14-33" aria-hidden="true" tabindex="-1"></a>      (col(<span class="st">&#39;W&#39;</span>).isNull()) <span class="op">&amp;</span> (col(<span class="st">&#39;O&#39;</span>).isNull()), <span class="dv">1</span>).otherwise(<span class="dv">0</span>))</span>
<span id="cb14-34"><a href="gps.html#cb14-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-35"><a href="gps.html#cb14-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># compute H and W id for wealth labels</span></span>
<span id="cb14-36"><a href="gps.html#cb14-36" aria-hidden="true" tabindex="-1"></a>  w <span class="op">=</span> Window.partitionBy(<span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb14-37"><a href="gps.html#cb14-37" aria-hidden="true" tabindex="-1"></a>  user_h_id <span class="op">=</span> (stops</span>
<span id="cb14-38"><a href="gps.html#cb14-38" aria-hidden="true" tabindex="-1"></a>               .where(col(<span class="st">&#39;location_type&#39;</span>) <span class="op">==</span> <span class="st">&#39;H&#39;</span>)</span>
<span id="cb14-39"><a href="gps.html#cb14-39" aria-hidden="true" tabindex="-1"></a>               .where(col(<span class="st">&#39;date_trunc&#39;</span>) <span class="op">&lt;=</span> <span class="st">&#39;2020-03-15&#39;</span>)</span>
<span id="cb14-40"><a href="gps.html#cb14-40" aria-hidden="true" tabindex="-1"></a>               .groupby(<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;geom_id&#39;</span>)</span>
<span id="cb14-41"><a href="gps.html#cb14-41" aria-hidden="true" tabindex="-1"></a>               .agg(F.countDistinct(<span class="st">&#39;date_trunc&#39;</span>).alias(<span class="st">&#39;n_days&#39;</span>))</span>
<span id="cb14-42"><a href="gps.html#cb14-42" aria-hidden="true" tabindex="-1"></a>               .withColumn(<span class="st">&#39;max_days&#39;</span>, F.<span class="bu">max</span>(<span class="st">&#39;n_days&#39;</span>).over(w))</span>
<span id="cb14-43"><a href="gps.html#cb14-43" aria-hidden="true" tabindex="-1"></a>               .where(col(<span class="st">&#39;n_days&#39;</span>) <span class="op">==</span> col(<span class="st">&#39;max_days&#39;</span>))</span>
<span id="cb14-44"><a href="gps.html#cb14-44" aria-hidden="true" tabindex="-1"></a>               .groupby(<span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb14-45"><a href="gps.html#cb14-45" aria-hidden="true" tabindex="-1"></a>               .agg(F.first(<span class="st">&#39;geom_id&#39;</span>).alias(<span class="st">&#39;geom_id_home&#39;</span>)))</span>
<span id="cb14-46"><a href="gps.html#cb14-46" aria-hidden="true" tabindex="-1"></a>  user_w_id <span class="op">=</span> (stops</span>
<span id="cb14-47"><a href="gps.html#cb14-47" aria-hidden="true" tabindex="-1"></a>               .where(col(<span class="st">&#39;location_type&#39;</span>) <span class="op">==</span> <span class="st">&#39;W&#39;</span>)</span>
<span id="cb14-48"><a href="gps.html#cb14-48" aria-hidden="true" tabindex="-1"></a>               <span class="co"># .where(col(&#39;date_trunc&#39;) &lt;= &#39;2020-03-15&#39;)</span></span>
<span id="cb14-49"><a href="gps.html#cb14-49" aria-hidden="true" tabindex="-1"></a>               .groupby(<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;geom_id&#39;</span>)</span>
<span id="cb14-50"><a href="gps.html#cb14-50" aria-hidden="true" tabindex="-1"></a>               .agg(F.countDistinct(<span class="st">&#39;date_trunc&#39;</span>).alias(<span class="st">&#39;n_days&#39;</span>))</span>
<span id="cb14-51"><a href="gps.html#cb14-51" aria-hidden="true" tabindex="-1"></a>               .withColumn(<span class="st">&#39;max_days&#39;</span>, F.<span class="bu">max</span>(<span class="st">&#39;n_days&#39;</span>).over(w))</span>
<span id="cb14-52"><a href="gps.html#cb14-52" aria-hidden="true" tabindex="-1"></a>               .where(col(<span class="st">&#39;n_days&#39;</span>) <span class="op">==</span> col(<span class="st">&#39;max_days&#39;</span>))</span>
<span id="cb14-53"><a href="gps.html#cb14-53" aria-hidden="true" tabindex="-1"></a>               .groupby(<span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb14-54"><a href="gps.html#cb14-54" aria-hidden="true" tabindex="-1"></a>               .agg(F.first(<span class="st">&#39;geom_id&#39;</span>).alias(<span class="st">&#39;geom_id_work&#39;</span>)))</span>
<span id="cb14-55"><a href="gps.html#cb14-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-56"><a href="gps.html#cb14-56" aria-hidden="true" tabindex="-1"></a>  durations_and_admins <span class="op">=</span> (durations</span>
<span id="cb14-57"><a href="gps.html#cb14-57" aria-hidden="true" tabindex="-1"></a>                          .withColumnRenamed(<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;date&#39;</span>)</span>
<span id="cb14-58"><a href="gps.html#cb14-58" aria-hidden="true" tabindex="-1"></a>                          .select(<span class="st">&#39;date&#39;</span>, <span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;H&#39;</span>, <span class="st">&#39;R&#39;</span>, <span class="st">&#39;W&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;O&#39;</span>)</span>
<span id="cb14-59"><a href="gps.html#cb14-59" aria-hidden="true" tabindex="-1"></a>                          .join(user_h_id, on<span class="op">=</span><span class="st">&#39;user_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;left&#39;</span>)</span>
<span id="cb14-60"><a href="gps.html#cb14-60" aria-hidden="true" tabindex="-1"></a>                          .join(user_w_id, on<span class="op">=</span><span class="st">&#39;user_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;left&#39;</span>))</span>
<span id="cb14-61"><a href="gps.html#cb14-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-62"><a href="gps.html#cb14-62" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> durations_and_admins</span></code></pre></div>
<p>The aggregation process takes the output of “compute_durations_and_admins” and compute the weighted average of the different metrics of interest.
Before focusing on the aggregated metrics produced, it is important to highlight that during this process metrics are reweighted based on the fraction of population living in administrative units in which at least one individual in our dataset is living. This step rebalance the data satial-coverage biases giving more importance to individuals living in administrative units with larger population.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="gps.html#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_durations_normalized_by_wealth_home(durations_and_admins, admins, labels_wealth, bins_wealth):</span>
<span id="cb15-2"><a href="gps.html#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb15-3"><a href="gps.html#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">    INPUT:  df output of &quot;compute_durations_and_admins&quot;, df (first) output of &quot;process_admins&quot;, wealth labels, wealth bins</span></span>
<span id="cb15-4"><a href="gps.html#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">    OUTPUT: df with weight column dataframe</span></span>
<span id="cb15-5"><a href="gps.html#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">  &#39;&#39;&#39;</span></span>
<span id="cb15-6"><a href="gps.html#cb15-6" aria-hidden="true" tabindex="-1"></a>  admins[<span class="st">&#39;wealth_label&#39;</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb15-7"><a href="gps.html#cb15-7" aria-hidden="true" tabindex="-1"></a>      admins[<span class="st">&#39;pct_wealth&#39;</span>], bins_wealth, labels<span class="op">=</span>labels_wealth)</span>
<span id="cb15-8"><a href="gps.html#cb15-8" aria-hidden="true" tabindex="-1"></a>  admins[<span class="st">&#39;geom_id&#39;</span>] <span class="op">=</span> admins[<span class="st">&#39;geom_id&#39;</span>].astype(<span class="bu">str</span>)</span>
<span id="cb15-9"><a href="gps.html#cb15-9" aria-hidden="true" tabindex="-1"></a>  admins[<span class="st">&#39;wealth_label&#39;</span>] <span class="op">=</span> admins[<span class="st">&#39;wealth_label&#39;</span>].astype(<span class="bu">str</span>)</span>
<span id="cb15-10"><a href="gps.html#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># get admin info for home and work location</span></span>
<span id="cb15-11"><a href="gps.html#cb15-11" aria-hidden="true" tabindex="-1"></a>  tmp1 <span class="op">=</span> spark.createDataFrame(</span>
<span id="cb15-12"><a href="gps.html#cb15-12" aria-hidden="true" tabindex="-1"></a>      admins[[<span class="st">&#39;geom_id&#39;</span>, <span class="st">&#39;pop&#39;</span>, <span class="st">&#39;pct_wealth&#39;</span>, <span class="st">&#39;wealth_label&#39;</span>]].rename(columns<span class="op">=</span><span class="kw">lambda</span> x: x<span class="op">+</span><span class="st">&#39;_home&#39;</span>))</span>
<span id="cb15-13"><a href="gps.html#cb15-13" aria-hidden="true" tabindex="-1"></a>  out1 <span class="op">=</span> (durations_and_admins</span>
<span id="cb15-14"><a href="gps.html#cb15-14" aria-hidden="true" tabindex="-1"></a>          .join(tmp1, on<span class="op">=</span><span class="st">&#39;geom_id_home&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>))</span>
<span id="cb15-15"><a href="gps.html#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="gps.html#cb15-16" aria-hidden="true" tabindex="-1"></a>  geom_users <span class="op">=</span> (out1</span>
<span id="cb15-17"><a href="gps.html#cb15-17" aria-hidden="true" tabindex="-1"></a>                .groupby(<span class="st">&#39;geom_id_home&#39;</span>)</span>
<span id="cb15-18"><a href="gps.html#cb15-18" aria-hidden="true" tabindex="-1"></a>                .agg(F.countDistinct(<span class="st">&#39;user_id&#39;</span>).alias(<span class="st">&#39;n_users&#39;</span>)))</span>
<span id="cb15-19"><a href="gps.html#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="gps.html#cb15-20" aria-hidden="true" tabindex="-1"></a>  out <span class="op">=</span> (out1</span>
<span id="cb15-21"><a href="gps.html#cb15-21" aria-hidden="true" tabindex="-1"></a>         .join(geom_users, on<span class="op">=</span><span class="st">&#39;geom_id_home&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>)</span>
<span id="cb15-22"><a href="gps.html#cb15-22" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;weight&#39;</span>, col(<span class="st">&#39;pop_home&#39;</span>)<span class="op">/</span>col(<span class="st">&#39;n_users&#39;</span>)))</span>
<span id="cb15-23"><a href="gps.html#cb15-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> out</span>
<span id="cb15-24"><a href="gps.html#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="gps.html#cb15-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-26"><a href="gps.html#cb15-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> output(out, column):</span>
<span id="cb15-27"><a href="gps.html#cb15-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb15-28"><a href="gps.html#cb15-28" aria-hidden="true" tabindex="-1"></a><span class="co">    INPUT:  df output of &quot;compute_durations_normalized_by_wealth_home&quot;, measure to aggregate</span></span>
<span id="cb15-29"><a href="gps.html#cb15-29" aria-hidden="true" tabindex="-1"></a><span class="co">    OUTPUT: aggregated and normalized dataframe</span></span>
<span id="cb15-30"><a href="gps.html#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="co">  &#39;&#39;&#39;</span></span>
<span id="cb15-31"><a href="gps.html#cb15-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># compute aggregate measures</span></span>
<span id="cb15-32"><a href="gps.html#cb15-32" aria-hidden="true" tabindex="-1"></a>  out <span class="op">=</span> (out</span>
<span id="cb15-33"><a href="gps.html#cb15-33" aria-hidden="true" tabindex="-1"></a>         .fillna(<span class="dv">0</span>, subset<span class="op">=</span>column)</span>
<span id="cb15-34"><a href="gps.html#cb15-34" aria-hidden="true" tabindex="-1"></a>         .groupby(<span class="st">&#39;date&#39;</span>, <span class="st">&#39;wealth_label_home&#39;</span>)</span>
<span id="cb15-35"><a href="gps.html#cb15-35" aria-hidden="true" tabindex="-1"></a>         .agg((F.<span class="bu">sum</span>(col(column)<span class="op">*</span>col(<span class="st">&#39;weight&#39;</span>))<span class="op">/</span>F.<span class="bu">sum</span>(col(<span class="st">&#39;weight&#39;</span>))).alias(<span class="st">&#39;mean&#39;</span>),</span>
<span id="cb15-36"><a href="gps.html#cb15-36" aria-hidden="true" tabindex="-1"></a>              F.stddev(column).alias(<span class="st">&#39;std&#39;</span>),</span>
<span id="cb15-37"><a href="gps.html#cb15-37" aria-hidden="true" tabindex="-1"></a>              F.count(column).alias(<span class="st">&#39;n&#39;</span>),</span>
<span id="cb15-38"><a href="gps.html#cb15-38" aria-hidden="true" tabindex="-1"></a>              F.countDistinct(<span class="st">&#39;user_id&#39;</span>).alias(<span class="st">&#39;n_unique&#39;</span>))</span>
<span id="cb15-39"><a href="gps.html#cb15-39" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;sem&#39;</span>, col(<span class="st">&#39;std&#39;</span>)<span class="op">/</span>F.sqrt(col(<span class="st">&#39;n&#39;</span>)))</span>
<span id="cb15-40"><a href="gps.html#cb15-40" aria-hidden="true" tabindex="-1"></a>         .drop(<span class="st">&#39;std&#39;</span>))</span>
<span id="cb15-41"><a href="gps.html#cb15-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-42"><a href="gps.html#cb15-42" aria-hidden="true" tabindex="-1"></a>  durations_normalized_by_wealth_home <span class="op">=</span> out.toPandas(</span>
<span id="cb15-43"><a href="gps.html#cb15-43" aria-hidden="true" tabindex="-1"></a>  ).set_index([<span class="st">&#39;wealth_label_home&#39;</span>, <span class="st">&#39;date&#39;</span>])</span>
<span id="cb15-44"><a href="gps.html#cb15-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> durations_normalized_by_wealth_home</span></code></pre></div>
<div id="measuring-mobility-patterns" class="section level4" number="2.5.3.1">
<h4><span class="header-section-number">2.5.3.1</span> Measuring mobility patterns</h4>
<p>We can now go back and discuss the metrics coded so far which we selected as proxies of different aspect of individuals mobility behaviour.
“H” (time spent at home“),”W" (time spent at work), “O” (time spent in locations which are neither home nor work) are quantities directly computed as the weighted average of the time spent in three diferent location categories, namely, the home-locations of an individuals, its work locations, and all the other locations which are neither home nor work. Additionally, we also compute the fraction of people not leaving their home-location on an entire day, “R,” and the fraction of commuters going to their workplace on a specific date, “C.” All these quantities are computed and aggregated following the wealth bins provided (e.g. “low-income”: 0-40% wealth-index percentile, “middle income”: 40-80% wealth-index percentile, “high-income”: 80-100% wealth-index percentile). To further specialize on most fragile individuals’ groups, we focus our attention on i) the “low-income” individuals and their fraction of commuters, and ii) the “low-income” individuals and thir time spent at their work places. These two quantities aims at providing in-dept insights over the working behaviour and its changes during the pandeimc.</p>
<p>Here we report an example code using the functions presented in the previous sections and the data computed by running the preprocessing pipeline.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="gps.html#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb16-2"><a href="gps.html#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb16-3"><a href="gps.html#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb16-4"><a href="gps.html#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.dates <span class="im">as</span> mdates</span>
<span id="cb16-5"><a href="gps.html#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-6"><a href="gps.html#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb16-7"><a href="gps.html#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="gps.html#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyspark.sql.functions <span class="im">as</span> F</span>
<span id="cb16-9"><a href="gps.html#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pyspark.sql.functions <span class="im">import</span> col, desc, lit</span>
<span id="cb16-10"><a href="gps.html#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pyspark.sql <span class="im">import</span> Window</span>
<span id="cb16-11"><a href="gps.html#cb16-11" aria-hidden="true" tabindex="-1"></a>spark.conf.<span class="bu">set</span>(<span class="st">&quot;spark.sql.shuffle.partitions&quot;</span>, <span class="dv">1500</span>)</span>
<span id="cb16-12"><a href="gps.html#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="gps.html#cb16-13" aria-hidden="true" tabindex="-1"></a>start_baseline <span class="op">=</span> <span class="st">&#39;2020-02-01&#39;</span></span>
<span id="cb16-14"><a href="gps.html#cb16-14" aria-hidden="true" tabindex="-1"></a>end_baseline <span class="op">=</span> <span class="st">&#39;2020-03-01&#39;</span></span>
<span id="cb16-15"><a href="gps.html#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="gps.html#cb16-16" aria-hidden="true" tabindex="-1"></a>start_date <span class="op">=</span> <span class="st">&#39;2020-02-01&#39;</span></span>
<span id="cb16-17"><a href="gps.html#cb16-17" aria-hidden="true" tabindex="-1"></a>end_date <span class="op">=</span> <span class="st">&#39;2021-04-15&#39;</span></span>
<span id="cb16-18"><a href="gps.html#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="gps.html#cb16-19" aria-hidden="true" tabindex="-1"></a>results_dir <span class="op">=</span> <span class="st">&quot;SAVE_RESULTS_HERE&quot;</span></span>
<span id="cb16-20"><a href="gps.html#cb16-20" aria-hidden="true" tabindex="-1"></a>admin_path <span class="op">=</span> <span class="st">&quot;FIND_ADMIN_DATA_HERE&quot;</span> <span class="co"># country specific admin files should be stored as &quot;{admin_path}/{country}/admin.csv&quot;</span></span>
<span id="cb16-21"><a href="gps.html#cb16-21" aria-hidden="true" tabindex="-1"></a>stop_path <span class="op">=</span> <span class="st">&quot;FIND_PIPELINE_STOP_DATA_HERE&quot;</span></span>
<span id="cb16-22"><a href="gps.html#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="gps.html#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="co"># define wealth groups</span></span>
<span id="cb16-24"><a href="gps.html#cb16-24" aria-hidden="true" tabindex="-1"></a>bins_wealth <span class="op">=</span> [<span class="dv">0</span>, <span class="fl">0.4</span>, <span class="fl">0.8</span>, <span class="dv">1</span>]</span>
<span id="cb16-25"><a href="gps.html#cb16-25" aria-hidden="true" tabindex="-1"></a>bins_dist <span class="op">=</span> [<span class="dv">0</span>, <span class="fl">0.4</span>, <span class="fl">0.8</span>, <span class="dv">1</span>]</span>
<span id="cb16-26"><a href="gps.html#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="gps.html#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="co"># select countries for which produce metric results</span></span>
<span id="cb16-28"><a href="gps.html#cb16-28" aria-hidden="true" tabindex="-1"></a>countries <span class="op">=</span> [<span class="st">&#39;ID&#39;</span>, <span class="st">&#39;PH&#39;</span>, <span class="st">&#39;BR&#39;</span>, <span class="st">&#39;CO&#39;</span>, <span class="st">&#39;MX&#39;</span>, <span class="st">&#39;ZA&#39;</span>]</span>
<span id="cb16-29"><a href="gps.html#cb16-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-30"><a href="gps.html#cb16-30" aria-hidden="true" tabindex="-1"></a>c_dates <span class="op">=</span> {<span class="st">&#39;BR&#39;</span>: <span class="st">&#39;2021-05-16&#39;</span>,</span>
<span id="cb16-31"><a href="gps.html#cb16-31" aria-hidden="true" tabindex="-1"></a>           <span class="st">&#39;CO&#39;</span>: <span class="st">&#39;2021-05-16&#39;</span>,</span>
<span id="cb16-32"><a href="gps.html#cb16-32" aria-hidden="true" tabindex="-1"></a>           <span class="st">&#39;ID&#39;</span>: <span class="st">&#39;2021-05-16&#39;</span>,</span>
<span id="cb16-33"><a href="gps.html#cb16-33" aria-hidden="true" tabindex="-1"></a>           <span class="st">&#39;MX&#39;</span>: <span class="st">&#39;2021-05-16&#39;</span>,</span>
<span id="cb16-34"><a href="gps.html#cb16-34" aria-hidden="true" tabindex="-1"></a>           <span class="st">&#39;PH&#39;</span>: <span class="st">&#39;2021-05-16&#39;</span>,</span>
<span id="cb16-35"><a href="gps.html#cb16-35" aria-hidden="true" tabindex="-1"></a>           <span class="st">&#39;ZA&#39;</span>: <span class="st">&#39;2021-05-16&#39;</span>,</span>
<span id="cb16-36"><a href="gps.html#cb16-36" aria-hidden="true" tabindex="-1"></a>           <span class="st">&#39;AR&#39;</span>: <span class="st">&#39;2021-05-16&#39;</span>}</span>
<span id="cb16-37"><a href="gps.html#cb16-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-38"><a href="gps.html#cb16-38" aria-hidden="true" tabindex="-1"></a>activity_level <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb16-39"><a href="gps.html#cb16-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-40"><a href="gps.html#cb16-40" aria-hidden="true" tabindex="-1"></a>hw <span class="op">=</span> <span class="dv">49</span></span>
<span id="cb16-41"><a href="gps.html#cb16-41" aria-hidden="true" tabindex="-1"></a>ww <span class="op">=</span> <span class="dv">49</span></span>
<span id="cb16-42"><a href="gps.html#cb16-42" aria-hidden="true" tabindex="-1"></a>wa <span class="op">=</span> <span class="dv">3600</span></span>
<span id="cb16-43"><a href="gps.html#cb16-43" aria-hidden="true" tabindex="-1"></a>mph <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb16-44"><a href="gps.html#cb16-44" aria-hidden="true" tabindex="-1"></a>mpw <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb16-45"><a href="gps.html#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="gps.html#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="co"># smoothing window size</span></span>
<span id="cb16-47"><a href="gps.html#cb16-47" aria-hidden="true" tabindex="-1"></a>ma <span class="op">=</span> <span class="dv">28</span></span>
<span id="cb16-48"><a href="gps.html#cb16-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-49"><a href="gps.html#cb16-49" aria-hidden="true" tabindex="-1"></a><span class="co"># weath-group names</span></span>
<span id="cb16-50"><a href="gps.html#cb16-50" aria-hidden="true" tabindex="-1"></a>labels_wealth <span class="op">=</span> [x<span class="op">+</span><span class="st">&#39; (&#39;</span><span class="op">+</span><span class="bu">str</span>(<span class="bu">int</span>(bins_wealth[i]<span class="op">*</span><span class="dv">100</span>))<span class="op">+</span><span class="st">&#39;%-&#39;</span><span class="op">+</span><span class="bu">str</span>(<span class="bu">int</span>(bins_wealth[i<span class="op">+</span><span class="dv">1</span>]<span class="op">*</span><span class="dv">100</span>)) <span class="op">+</span><span class="st">&#39;%)&#39;</span> <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">range</span>(<span class="bu">len</span>(bins_wealth)<span class="op">-</span><span class="dv">1</span>), [<span class="st">&#39;Low&#39;</span>, <span class="st">&#39;Medium&#39;</span>, <span class="st">&#39;High&#39;</span>])]</span>
<span id="cb16-51"><a href="gps.html#cb16-51" aria-hidden="true" tabindex="-1"></a>labels_dist <span class="op">=</span> [x<span class="op">+</span><span class="st">&#39; (&#39;</span><span class="op">+</span><span class="bu">str</span>(<span class="bu">int</span>(bins_dist[i]<span class="op">*</span><span class="dv">100</span>))<span class="op">+</span><span class="st">&#39;%-&#39;</span><span class="op">+</span><span class="bu">str</span>(<span class="bu">int</span>(bins_dist[i<span class="op">+</span><span class="dv">1</span>]<span class="op">*</span><span class="dv">100</span>)) <span class="op">+</span><span class="st">&#39;%)&#39;</span> <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">range</span>(<span class="bu">len</span>(bins_dist)<span class="op">-</span><span class="dv">1</span>), [<span class="st">&#39;Low&#39;</span>, <span class="st">&#39;Medium&#39;</span>, <span class="st">&#39;High&#39;</span>])]</span>
<span id="cb16-52"><a href="gps.html#cb16-52" aria-hidden="true" tabindex="-1"></a><span class="co"># largest metropolis names</span></span>
<span id="cb16-53"><a href="gps.html#cb16-53" aria-hidden="true" tabindex="-1"></a>country_capitals <span class="op">=</span> {<span class="st">&#39;MX&#39;</span>: <span class="st">&#39;Mexico City&#39;</span>, <span class="st">&#39;BR&#39;</span>: <span class="st">&#39;São Paulo&#39;</span>, <span class="st">&#39;CO&#39;</span>: <span class="st">&#39;Bogota&#39;</span>, <span class="st">&#39;PH&#39;</span>: <span class="st">&#39;Quezon City [Manila]&#39;</span>, <span class="st">&#39;ID&#39;</span>: <span class="st">&#39;Jakarta&#39;</span>, <span class="st">&#39;ZA&#39;</span>: <span class="st">&#39;Johannesburg&#39;</span>, <span class="st">&#39;AR&#39;</span>: <span class="st">&#39;GBuenos Aires&#39;</span>}</span>
<span id="cb16-54"><a href="gps.html#cb16-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-55"><a href="gps.html#cb16-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-56"><a href="gps.html#cb16-56" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize dictionary where to store results</span></span>
<span id="cb16-57"><a href="gps.html#cb16-57" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb16-58"><a href="gps.html#cb16-58" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> country <span class="kw">in</span> countries:</span>
<span id="cb16-59"><a href="gps.html#cb16-59" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(country)</span>
<span id="cb16-60"><a href="gps.html#cb16-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-61"><a href="gps.html#cb16-61" aria-hidden="true" tabindex="-1"></a>    admins_by_country, admins_by_metro_area, pop_metro_areas <span class="op">=</span> process_admin(country,admin_path)</span>
<span id="cb16-62"><a href="gps.html#cb16-62" aria-hidden="true" tabindex="-1"></a>    capital_geomid <span class="op">=</span> admins_by_metro_area[admins_by_metro_area.metro_area_name <span class="op">==</span> country_capitals[country]].geom_id.unique().tolist()</span>
<span id="cb16-63"><a href="gps.html#cb16-63" aria-hidden="true" tabindex="-1"></a>    durations_and_admins <span class="op">=</span> compute_durations_and_admins(country, c_dates[country], stop_path, activity_level<span class="op">=</span>activity_level, hw<span class="op">=</span>hw, ww<span class="op">=</span>ww, wa<span class="op">=</span>wa, mph<span class="op">=</span>mph, mpw<span class="op">=</span>mpw)</span>
<span id="cb16-64"><a href="gps.html#cb16-64" aria-hidden="true" tabindex="-1"></a>    durations_and_admins.cache()</span>
<span id="cb16-65"><a href="gps.html#cb16-65" aria-hidden="true" tabindex="-1"></a>    out1 <span class="op">=</span> compute_durations_normalized_by_wealth_home(durations_and_admins, admins_by_country, labels_wealth, bins_wealth)</span>
<span id="cb16-66"><a href="gps.html#cb16-66" aria-hidden="true" tabindex="-1"></a>    out2 <span class="op">=</span> compute_durations_normalized_by_wealth_home_wealth_work(durations_and_admins, admins_by_country, labels_wealth, bins_wealth)</span>
<span id="cb16-67"><a href="gps.html#cb16-67" aria-hidden="true" tabindex="-1"></a>    results[(country, <span class="st">&#39;t_home&#39;</span>)] <span class="op">=</span> output(out1, column<span class="op">=</span><span class="st">&#39;H&#39;</span>)</span>
<span id="cb16-68"><a href="gps.html#cb16-68" aria-hidden="true" tabindex="-1"></a>    results[(country, <span class="st">&#39;t_work&#39;</span>)] <span class="op">=</span> output(out1, column<span class="op">=</span><span class="st">&#39;W&#39;</span>)</span>
<span id="cb16-69"><a href="gps.html#cb16-69" aria-hidden="true" tabindex="-1"></a>    results[(country, <span class="st">&#39;t_other&#39;</span>)] <span class="op">=</span> output(out1, column<span class="op">=</span><span class="st">&#39;O&#39;</span>)</span>
<span id="cb16-70"><a href="gps.html#cb16-70" aria-hidden="true" tabindex="-1"></a>    results[(country, <span class="st">&#39;rec&#39;</span>)] <span class="op">=</span> output(out1, column<span class="op">=</span><span class="st">&#39;R&#39;</span>)</span>
<span id="cb16-71"><a href="gps.html#cb16-71" aria-hidden="true" tabindex="-1"></a>    results[(country, <span class="st">&#39;comms&#39;</span>)] <span class="op">=</span> output(out1, column<span class="op">=</span><span class="st">&#39;C&#39;</span>)</span>
<span id="cb16-72"><a href="gps.html#cb16-72" aria-hidden="true" tabindex="-1"></a>    results[(country, <span class="st">&#39;comms_hw&#39;</span>)] <span class="op">=</span> output_hw(out2, column<span class="op">=</span><span class="st">&#39;C&#39;</span>)</span>
<span id="cb16-73"><a href="gps.html#cb16-73" aria-hidden="true" tabindex="-1"></a>    results[(country, <span class="st">&#39;t_work_hw&#39;</span>)] <span class="op">=</span> output_hw(out2, column<span class="op">=</span><span class="st">&#39;W&#39;</span>)</span>
<span id="cb16-74"><a href="gps.html#cb16-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-75"><a href="gps.html#cb16-75" aria-hidden="true" tabindex="-1"></a>    durations_and_admins.unpersist()</span>
<span id="cb16-76"><a href="gps.html#cb16-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-77"><a href="gps.html#cb16-77" aria-hidden="true" tabindex="-1"></a><span class="co"># save all countries results in a single .csv file</span></span>
<span id="cb16-78"><a href="gps.html#cb16-78" aria-hidden="true" tabindex="-1"></a>res2 <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">&#39;state&#39;</span>, <span class="st">&#39;measure&#39;</span>,</span>
<span id="cb16-79"><a href="gps.html#cb16-79" aria-hidden="true" tabindex="-1"></a>                             <span class="st">&#39;wealth_label_home&#39;</span>, <span class="st">&#39;date&#39;</span>, <span class="st">&#39;mean&#39;</span>, <span class="st">&#39;sem&#39;</span>])</span>
<span id="cb16-80"><a href="gps.html#cb16-80" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, res <span class="kw">in</span> results.items():</span>
<span id="cb16-81"><a href="gps.html#cb16-81" aria-hidden="true" tabindex="-1"></a>    res_tmp <span class="op">=</span> res.reset_index().copy()</span>
<span id="cb16-82"><a href="gps.html#cb16-82" aria-hidden="true" tabindex="-1"></a>    res_tmp[<span class="st">&#39;state&#39;</span>], res_tmp[<span class="st">&#39;measure&#39;</span>] <span class="op">=</span> key</span>
<span id="cb16-83"><a href="gps.html#cb16-83" aria-hidden="true" tabindex="-1"></a>    res2 <span class="op">=</span> res2.append(res_tmp, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-84"><a href="gps.html#cb16-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-85"><a href="gps.html#cb16-85" aria-hidden="true" tabindex="-1"></a>res2.to_csv(results_dir<span class="op">+</span><span class="st">&#39;all_hw_weighted.csv&#39;</span>)</span></code></pre></div>
</div>
<div id="measuring-change" class="section level4" number="2.5.3.2">
<h4><span class="header-section-number">2.5.3.2</span> Measuring change</h4>
<p>It is of particular interest, due to the dramatic societal impact the pandemic had at a global scale, to study these quantities in relation to the pre-pandemic periods. A comparison bethween individuals mobility behaviour from the months preceding the explosive diffusion of the SARS-ncov virus represent an important indicator of how much each socio-economic group was affected by the local regulations and how individuals were forced to reshape their daily mobility patterns in response to the pandemic threat. To this extent, we implemented a change metric which directly compare the levels of the metrics discussed in terms of the period going from the beginning of January 2020 and March 15, 2020. Change is computed on a daily basis, comparing the level of a specific date with the day-of-the-week median value of the same metric. This accounts for weekly periodical effects, accounting, for example, for the physiological reduction in the number of commuters during weekends.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="gps.html#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> google_change_metric(df_original, start_baseline, end_baseline,other_groups<span class="op">=</span>[]):</span>
<span id="cb17-2"><a href="gps.html#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb17-3"><a href="gps.html#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">  INPUT:  dataframe with (at least) 2 columns named &quot;mean&quot; and &quot;sem&quot;</span></span>
<span id="cb17-4"><a href="gps.html#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">  OUTPUT: dataframe with the values of the two columns converted to google change metric</span></span>
<span id="cb17-5"><a href="gps.html#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">  </span><span class="al">NOTE</span><span class="co">: Google uses as baseline period the 5-weeks period from Jan 3 to Feb 6</span></span>
<span id="cb17-6"><a href="gps.html#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">  &#39;&#39;&#39;</span></span>
<span id="cb17-7"><a href="gps.html#cb17-7" aria-hidden="true" tabindex="-1"></a>  df <span class="op">=</span> df_original.copy()</span>
<span id="cb17-8"><a href="gps.html#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="gps.html#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># compute weekday baseline values</span></span>
<span id="cb17-10"><a href="gps.html#cb17-10" aria-hidden="true" tabindex="-1"></a>  baseline <span class="op">=</span> df.loc[start_baseline:end_baseline,[<span class="st">&#39;mean&#39;</span>,<span class="st">&#39;sem&#39;</span>]<span class="op">+</span>other_groups].copy()</span>
<span id="cb17-11"><a href="gps.html#cb17-11" aria-hidden="true" tabindex="-1"></a>  baseline[<span class="st">&#39;weekday&#39;</span>] <span class="op">=</span> <span class="bu">list</span>(baseline.index.dayofweek.values)</span>
<span id="cb17-12"><a href="gps.html#cb17-12" aria-hidden="true" tabindex="-1"></a>  baseline <span class="op">=</span> baseline.groupby([<span class="st">&#39;weekday&#39;</span>]<span class="op">+</span>other_groups,dropna<span class="op">=</span><span class="va">False</span>,as_index<span class="op">=</span><span class="va">False</span>).mean()</span>
<span id="cb17-13"><a href="gps.html#cb17-13" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">&#39;weekday&#39;</span>] <span class="op">=</span> <span class="bu">list</span>(df.index.dayofweek.values)</span>
<span id="cb17-14"><a href="gps.html#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="gps.html#cb17-15" aria-hidden="true" tabindex="-1"></a>  date <span class="op">=</span> df.index.copy()</span>
<span id="cb17-16"><a href="gps.html#cb17-16" aria-hidden="true" tabindex="-1"></a>  df <span class="op">=</span> df.merge(baseline, on<span class="op">=</span>[<span class="st">&#39;weekday&#39;</span>]<span class="op">+</span>other_groups, how<span class="op">=</span><span class="st">&#39;left&#39;</span>, <span class="op">=</span>(<span class="st">&#39;&#39;</span>, <span class="st">&#39;_baseline&#39;</span>))</span>
<span id="cb17-17"><a href="gps.html#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="gps.html#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># compute &quot;mean&quot; change with respect to weekday baseline values</span></span>
<span id="cb17-19"><a href="gps.html#cb17-19" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">&#39;mean&#39;</span>] <span class="op">=</span> (df[<span class="st">&#39;mean&#39;</span>]<span class="op">-</span> df[<span class="st">&#39;mean_baseline&#39;</span>]) <span class="op">/</span> np.<span class="bu">abs</span>(df[<span class="st">&#39;mean_baseline&#39;</span>])</span>
<span id="cb17-20"><a href="gps.html#cb17-20" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">&#39;sem&#39;</span>] <span class="op">=</span> np.<span class="bu">abs</span>(df[<span class="st">&#39;sem&#39;</span>]<span class="op">/</span>df[<span class="st">&#39;mean_baseline&#39;</span>])</span>
<span id="cb17-21"><a href="gps.html#cb17-21" aria-hidden="true" tabindex="-1"></a>  df.index <span class="op">=</span> date</span>
<span id="cb17-22"><a href="gps.html#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="gps.html#cb17-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># return input dataframe with &quot;mean&quot; and &quot;sem&quot; column now expressing the relative change and its error</span></span>
<span id="cb17-24"><a href="gps.html#cb17-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> df.drop([<span class="st">&#39;weekday&#39;</span>,<span class="st">&#39;mean_baseline&#39;</span>],axis<span class="op">=</span><span class="dv">1</span>,errors<span class="op">=</span><span class="st">&#39;ignore&#39;</span>)</span></code></pre></div>
</div>
<div id="home-isolated-commuters-and-low-wealth-commuters" class="section level4" number="2.5.3.3">
<h4><span class="header-section-number">2.5.3.3</span> Home-isolated, commuters and low-wealth commuters</h4>
<p>In this section we present a summary of the results for three different metrics computed for six different countries. Countries are selected among middle-low income countries to include at least one state on three different continents: America, Asia and Africa. Similar pattern changes are found between socio-economics groups across the globe.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:mobility-fig"></span>
<img src="big-daa_files/figure-html/mobility-fig-1.png" alt="Results for six different countries (rows): Brazil, Colombia, Indonesia, Mexico, Philippines, and South Africa. Measuring (columns): relative change in the fraction of people not leaving home, relative change of the number of people commuting from home to workplace, relative change of individuals from living in low-wealth admin units. The three coloured lines distinguishes the metric changes for the three different socio-economic groups." width="80%" />
<p class="caption">
Figure 2.4: Results for six different countries (rows): Brazil, Colombia, Indonesia, Mexico, Philippines, and South Africa. Measuring (columns): relative change in the fraction of people not leaving home, relative change of the number of people commuting from home to workplace, relative change of individuals from living in low-wealth admin units. The three coloured lines distinguishes the metric changes for the three different socio-economic groups.
</p>
</div>

</div>
</div>
</div>
<div id="migration" class="section level2" number="2.6">
<h2><span class="header-section-number">2.6</span> Migration Patterns</h2>
<div id="description" class="section level3" number="2.6.1">
<h3><span class="header-section-number">2.6.1</span> Description</h3>
<p>A great amount of <a href="https://www.nytimes.com/2021/05/12/opinion/New-York-San-Francisco-after-covid.html">media attention</a> has
been focusing on how large cities are being empitied out by the pandemic.
We are also interested in this behavior and used similar process as the described in the previous chapter <a href="gps.html#mobility">2.5</a>,
and as the home labeling process we did allowed for multiple homes in a certain time window then we could
use a change of administrative unit in the residential location of the users. For this study we focused on the largest
city of each country:</p>
<table>
<thead>
<tr class="header">
<th align="left">Country</th>
<th align="left">Code</th>
<th align="left">City</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Brazil</td>
<td align="left">BR</td>
<td align="left">São Paulo</td>
</tr>
<tr class="even">
<td align="left">Colombia</td>
<td align="left">CO</td>
<td align="left">Bogota</td>
</tr>
<tr class="odd">
<td align="left">Indonesia</td>
<td align="left">ID</td>
<td align="left">Jakarta</td>
</tr>
<tr class="even">
<td align="left">Mexico</td>
<td align="left">MX</td>
<td align="left">Mexico City</td>
</tr>
<tr class="odd">
<td align="left">Philippines</td>
<td align="left">PH</td>
<td align="left">Quezon City (Manila)</td>
</tr>
<tr class="even">
<td align="left">South Africa</td>
<td align="left">ZA</td>
<td align="left">Johannesburg</td>
</tr>
</tbody>
</table>
</div>
<div id="user-selection" class="section level3" number="2.6.2">
<h3><span class="header-section-number">2.6.2</span> User selection</h3>
<p>Here, we restrict our sample <a href="gps.html#selection">2.5.2</a> of individuals to only active users (as defined in the previous chapter) who had a home location in the city at any given time. It’s important to note that although we use the term <em>city</em> we are using the whole extent of their metropolitan
area.</p>
<p>In order to determine a wealth group for them we take the administrative unit they had at the moment when their home
location was in the city and in case they had more than one we only kept the one where the most time was spent.
The wealth percentiles represent the cummulative population of the administrative units ordered by their wealth index.
This means that users that fall into the <em>Low [0%-40%]</em> group are the ones with their house in the areas with the
lowest wealth index that make up to <span class="math inline">\(40\%\)</span> of the population.</p>
</div>
<div id="code-2" class="section level3" number="2.6.3">
<h3><span class="header-section-number">2.6.3</span> Code</h3>
<p>We select the largest city and break their wealth index in 3 bins. And define a column to discern from urban and rural places.
The bins and labels are the same as the ones from the previous chapter <a href="gps.html#mobility">2.5</a>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="gps.html#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_admin(country):</span>
<span id="cb18-2"><a href="gps.html#cb18-2" aria-hidden="true" tabindex="-1"></a>  admin_path <span class="op">=</span> <span class="ss">f&#39;/mnt/Geospatial/admin/</span><span class="sc">{</span>country<span class="sc">}</span><span class="ss">/admin.csv&#39;</span></span>
<span id="cb18-3"><a href="gps.html#cb18-3" aria-hidden="true" tabindex="-1"></a>  admin <span class="op">=</span> spark.read.option(<span class="st">&#39;header&#39;</span>, <span class="st">&#39;true&#39;</span>).csv(admin_path)</span>
<span id="cb18-4"><a href="gps.html#cb18-4" aria-hidden="true" tabindex="-1"></a>  admin <span class="op">=</span> (admin</span>
<span id="cb18-5"><a href="gps.html#cb18-5" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;urban/rural&#39;</span>, F.when(col(<span class="st">&#39;metro_area_name&#39;</span>).isNull(), lit(<span class="st">&#39;rural&#39;</span>)).otherwise(lit(<span class="st">&#39;urban&#39;</span>)))</span>
<span id="cb18-6"><a href="gps.html#cb18-6" aria-hidden="true" tabindex="-1"></a>           .select(<span class="st">&#39;geom_id&#39;</span>, <span class="st">&#39;urban/rural&#39;</span>))</span>
<span id="cb18-7"><a href="gps.html#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> admin</span>
<span id="cb18-8"><a href="gps.html#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="gps.html#cb18-9" aria-hidden="true" tabindex="-1"></a>admins, admins_by_metro_area, pops <span class="op">=</span> process_admin(country)</span>
<span id="cb18-10"><a href="gps.html#cb18-10" aria-hidden="true" tabindex="-1"></a>admins[<span class="st">&#39;geom_id&#39;</span>] <span class="op">=</span> admins[<span class="st">&#39;geom_id&#39;</span>].astype(<span class="bu">str</span>)</span>
<span id="cb18-11"><a href="gps.html#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="gps.html#cb18-12" aria-hidden="true" tabindex="-1"></a>admins_by_metro_area[<span class="st">&#39;wealth_label&#39;</span>] <span class="op">=</span> pd.cut(admins_by_metro_area[<span class="st">&#39;pct_wealth&#39;</span>], bins_wealth, labels<span class="op">=</span>labels_wealth)</span>
<span id="cb18-13"><a href="gps.html#cb18-13" aria-hidden="true" tabindex="-1"></a>admins_by_metro_area[<span class="st">&#39;geom_id&#39;</span>] <span class="op">=</span> admins_by_metro_area[<span class="st">&#39;geom_id&#39;</span>].astype(<span class="bu">str</span>)</span>
<span id="cb18-14"><a href="gps.html#cb18-14" aria-hidden="true" tabindex="-1"></a>admins_by_metro_area[<span class="st">&#39;wealth_label&#39;</span>] <span class="op">=</span> admins_by_metro_area[<span class="st">&#39;wealth_label&#39;</span>].astype(<span class="bu">str</span>)</span>
<span id="cb18-15"><a href="gps.html#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="gps.html#cb18-16" aria-hidden="true" tabindex="-1"></a>admins_by_metro_area <span class="op">=</span> admins_by_metro_area.loc[admins_by_metro_area.metro_area_name <span class="op">==</span> pops.reset_index().metro_area_name[<span class="dv">0</span>]]</span>
<span id="cb18-17"><a href="gps.html#cb18-17" aria-hidden="true" tabindex="-1"></a>admins <span class="op">=</span> spark.createDataFrame(admins_by_metro_area).select(<span class="st">&#39;geom_id&#39;</span>, <span class="st">&#39;wealth_label&#39;</span>)</span>
<span id="cb18-18"><a href="gps.html#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="gps.html#cb18-19" aria-hidden="true" tabindex="-1"></a>admin_rural <span class="op">=</span> read_admin(country)</span></code></pre></div>
<p>Then we select our user sample, which are the ones with a minimum percentage of active days (<span class="math inline">\(20\%\)</span>) using the same function
<em>get_active_list()</em> and select the users with a home in the city.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="gps.html#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get list of active users</span></span>
<span id="cb19-2"><a href="gps.html#cb19-2" aria-hidden="true" tabindex="-1"></a>personal_nf <span class="op">=</span> <span class="ss">f&quot;personal_stop_location_hw</span><span class="sc">{hw}</span><span class="ss">_ww</span><span class="sc">{ww}</span><span class="ss">_wa</span><span class="sc">{wa}</span><span class="ss">_mph</span><span class="sc">{</span>mph<span class="sc">}</span><span class="ss">_mpw</span><span class="sc">{</span>mpw<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb19-3"><a href="gps.html#cb19-3" aria-hidden="true" tabindex="-1"></a>stops <span class="op">=</span> spark.read.parquet(<span class="ss">f&quot;</span><span class="sc">{</span>stop_path<span class="sc">}{</span>country<span class="sc">}</span><span class="ss">/accuracy100_maxtimestop3600_staytime300_radius50_dbscanradius50/date</span><span class="sc">{</span>data_date<span class="sc">}</span><span class="ss">/&quot;</span> <span class="op">+</span> personal_nf)</span>
<span id="cb19-4"><a href="gps.html#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="gps.html#cb19-5" aria-hidden="true" tabindex="-1"></a>fname_nf <span class="op">=</span> <span class="ss">f&#39;durations_window_hw</span><span class="sc">{hw}</span><span class="ss">_ww</span><span class="sc">{ww}</span><span class="ss">_wa</span><span class="sc">{wa}</span><span class="ss">_mph</span><span class="sc">{</span>mph<span class="sc">}</span><span class="ss">_mpw</span><span class="sc">{</span>mpw<span class="sc">}</span><span class="ss">&#39;</span></span>
<span id="cb19-6"><a href="gps.html#cb19-6" aria-hidden="true" tabindex="-1"></a>durations_path_nf <span class="op">=</span> <span class="ss">f&#39;</span><span class="sc">{</span>stop_path<span class="sc">}{</span>country<span class="sc">}</span><span class="ss">/accuracy100_maxtimestop3600_staytime300_radius50_dbscanradius50/date</span><span class="sc">{</span>data_date<span class="sc">}</span><span class="ss">/&#39;</span> <span class="op">+</span> fname_nf</span>
<span id="cb19-7"><a href="gps.html#cb19-7" aria-hidden="true" tabindex="-1"></a>durations <span class="op">=</span> spark.read.parquet(durations_path_nf)</span>
<span id="cb19-8"><a href="gps.html#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="gps.html#cb19-9" aria-hidden="true" tabindex="-1"></a>active_users <span class="op">=</span> get_active_list(durations, country, activity_level)</span>
<span id="cb19-10"><a href="gps.html#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="gps.html#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co"># read stops, filter actives, get most frequented daily geom id, and get rural/urban info</span></span>
<span id="cb19-12"><a href="gps.html#cb19-12" aria-hidden="true" tabindex="-1"></a>admins_by_country, admins_by_metro_area, pop_metro_areas <span class="op">=</span> process_admin(country)</span>
<span id="cb19-13"><a href="gps.html#cb19-13" aria-hidden="true" tabindex="-1"></a>metro <span class="op">=</span> (admins_by_metro_area</span>
<span id="cb19-14"><a href="gps.html#cb19-14" aria-hidden="true" tabindex="-1"></a>         .loc[admins_by_metro_area.metro_area_name <span class="op">==</span> pop_metro_areas</span>
<span id="cb19-15"><a href="gps.html#cb19-15" aria-hidden="true" tabindex="-1"></a>              .reset_index()</span>
<span id="cb19-16"><a href="gps.html#cb19-16" aria-hidden="true" tabindex="-1"></a>              .head(<span class="dv">1</span>)</span>
<span id="cb19-17"><a href="gps.html#cb19-17" aria-hidden="true" tabindex="-1"></a>              .metro_area_name</span>
<span id="cb19-18"><a href="gps.html#cb19-18" aria-hidden="true" tabindex="-1"></a>              .to_list()[<span class="dv">0</span>]][<span class="st">&quot;geom_id&quot;</span>]</span>
<span id="cb19-19"><a href="gps.html#cb19-19" aria-hidden="true" tabindex="-1"></a>         .to_list())</span>
<span id="cb19-20"><a href="gps.html#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="gps.html#cb19-21" aria-hidden="true" tabindex="-1"></a>users_metro <span class="op">=</span> stops.where(col(<span class="st">&#39;location_type&#39;</span>) <span class="op">==</span> <span class="st">&#39;H&#39;</span>).<span class="bu">filter</span>(F.col(<span class="st">&quot;geom_id&quot;</span>).isin(metro)).select(<span class="st">&#39;user_id&#39;</span>).distinct()</span>
<span id="cb19-22"><a href="gps.html#cb19-22" aria-hidden="true" tabindex="-1"></a>stops <span class="op">=</span> stops.join(users_metro, on<span class="op">=</span><span class="st">&#39;user_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>).join(active_users, on<span class="op">=</span><span class="st">&#39;user_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>)</span>
<span id="cb19-23"><a href="gps.html#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="gps.html#cb19-24" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> Window.partitionBy(<span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb19-25"><a href="gps.html#cb19-25" aria-hidden="true" tabindex="-1"></a>user_geom <span class="op">=</span> (stops</span>
<span id="cb19-26"><a href="gps.html#cb19-26" aria-hidden="true" tabindex="-1"></a>           .where(col(<span class="st">&#39;location_type&#39;</span>) <span class="op">==</span> <span class="st">&#39;H&#39;</span>)</span>
<span id="cb19-27"><a href="gps.html#cb19-27" aria-hidden="true" tabindex="-1"></a>           .<span class="bu">filter</span>(F.col(<span class="st">&quot;geom_id&quot;</span>).isin(metro))</span>
<span id="cb19-28"><a href="gps.html#cb19-28" aria-hidden="true" tabindex="-1"></a>           .groupby(<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;geom_id&#39;</span>)</span>
<span id="cb19-29"><a href="gps.html#cb19-29" aria-hidden="true" tabindex="-1"></a>           .agg(F.countDistinct(<span class="st">&#39;date_trunc&#39;</span>).alias(<span class="st">&#39;n_days&#39;</span>))</span>
<span id="cb19-30"><a href="gps.html#cb19-30" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;max_days&#39;</span>, F.<span class="bu">max</span>(<span class="st">&#39;n_days&#39;</span>).over(w))</span>
<span id="cb19-31"><a href="gps.html#cb19-31" aria-hidden="true" tabindex="-1"></a>           .where(col(<span class="st">&#39;n_days&#39;</span>) <span class="op">==</span> col(<span class="st">&#39;max_days&#39;</span>))</span>
<span id="cb19-32"><a href="gps.html#cb19-32" aria-hidden="true" tabindex="-1"></a>           .groupby(<span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb19-33"><a href="gps.html#cb19-33" aria-hidden="true" tabindex="-1"></a>           .agg(F.first(<span class="st">&#39;geom_id&#39;</span>).alias(<span class="st">&#39;geom_id&#39;</span>))</span>
<span id="cb19-34"><a href="gps.html#cb19-34" aria-hidden="true" tabindex="-1"></a>           .join(admins, on<span class="op">=</span><span class="st">&#39;geom_id&#39;</span>)</span>
<span id="cb19-35"><a href="gps.html#cb19-35" aria-hidden="true" tabindex="-1"></a>           .drop(<span class="st">&#39;geom_id&#39;</span>))</span>
<span id="cb19-36"><a href="gps.html#cb19-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-37"><a href="gps.html#cb19-37" aria-hidden="true" tabindex="-1"></a>usrs <span class="op">=</span>  (user_geom</span>
<span id="cb19-38"><a href="gps.html#cb19-38" aria-hidden="true" tabindex="-1"></a>       .join(active_users, on<span class="op">=</span><span class="st">&#39;user_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>)</span>
<span id="cb19-39"><a href="gps.html#cb19-39" aria-hidden="true" tabindex="-1"></a>       .toPandas())</span>
<span id="cb19-40"><a href="gps.html#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-41"><a href="gps.html#cb19-41" aria-hidden="true" tabindex="-1"></a>usrs[<span class="st">&quot;country&quot;</span>] <span class="op">=</span> country</span>
<span id="cb19-42"><a href="gps.html#cb19-42" aria-hidden="true" tabindex="-1"></a>usr_df <span class="op">=</span> pd.concat([usr_df, usrs])</span>
<span id="cb19-43"><a href="gps.html#cb19-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-44"><a href="gps.html#cb19-44" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> Window.partitionBy(<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>)</span>
<span id="cb19-45"><a href="gps.html#cb19-45" aria-hidden="true" tabindex="-1"></a>h_stops <span class="op">=</span> (stops</span>
<span id="cb19-46"><a href="gps.html#cb19-46" aria-hidden="true" tabindex="-1"></a>         .where(col(<span class="st">&#39;location_type&#39;</span>) <span class="op">==</span> <span class="st">&#39;H&#39;</span>)</span>
<span id="cb19-47"><a href="gps.html#cb19-47" aria-hidden="true" tabindex="-1"></a>         .join(active_users, on<span class="op">=</span><span class="st">&#39;user_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>)</span>
<span id="cb19-48"><a href="gps.html#cb19-48" aria-hidden="true" tabindex="-1"></a>         .groupby(<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;geom_id&#39;</span>)</span>
<span id="cb19-49"><a href="gps.html#cb19-49" aria-hidden="true" tabindex="-1"></a>         .agg(F.<span class="bu">sum</span>(<span class="st">&#39;duration&#39;</span>).alias(<span class="st">&#39;duration&#39;</span>))</span>
<span id="cb19-50"><a href="gps.html#cb19-50" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;max_duration&#39;</span>, F.<span class="bu">max</span>(<span class="st">&#39;duration&#39;</span>).over(w))</span>
<span id="cb19-51"><a href="gps.html#cb19-51" aria-hidden="true" tabindex="-1"></a>         .where(col(<span class="st">&#39;duration&#39;</span>) <span class="op">==</span> col(<span class="st">&#39;max_duration&#39;</span>))</span>
<span id="cb19-52"><a href="gps.html#cb19-52" aria-hidden="true" tabindex="-1"></a>         .groupby(<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;date_trunc&#39;</span>)</span>
<span id="cb19-53"><a href="gps.html#cb19-53" aria-hidden="true" tabindex="-1"></a>         .agg(F.first(<span class="st">&#39;geom_id&#39;</span>).alias(<span class="st">&#39;geom_id&#39;</span>))</span>
<span id="cb19-54"><a href="gps.html#cb19-54" aria-hidden="true" tabindex="-1"></a>         .join(admin_rural, on<span class="op">=</span><span class="st">&#39;geom_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>)</span>
<span id="cb19-55"><a href="gps.html#cb19-55" aria-hidden="true" tabindex="-1"></a>         .join(user_geom, on<span class="op">=</span><span class="st">&#39;user_id&#39;</span>, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>))</span></code></pre></div>
<p>Now that we have defined the home locations of each user we compare the location of the homes from one day
to the one a day before. We are interested in migrations to rural areas, so this time we’re not taking into account
if they moved to a different urban area. Then we put a flag on each user every day to tell if they moved or not and if
they did, knowing if they moved from an urban area to a rural one or the other way around.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="gps.html#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># look-up previous geom id to identify migrations with direction</span></span>
<span id="cb20-2"><a href="gps.html#cb20-2" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> Window.partitionBy(<span class="st">&#39;user_id&#39;</span>).orderBy(<span class="st">&#39;date_trunc&#39;</span>)</span>
<span id="cb20-3"><a href="gps.html#cb20-3" aria-hidden="true" tabindex="-1"></a>h_stops <span class="op">=</span> (h_stops</span>
<span id="cb20-4"><a href="gps.html#cb20-4" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;prev_geom_id&#39;</span>, F.lag(<span class="st">&#39;geom_id&#39;</span>, offset<span class="op">=</span><span class="dv">1</span>).over(w))</span>
<span id="cb20-5"><a href="gps.html#cb20-5" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;prev_urban/rural&#39;</span>, F.lag(<span class="st">&#39;urban/rural&#39;</span>, offset<span class="op">=</span><span class="dv">1</span>).over(w))</span>
<span id="cb20-6"><a href="gps.html#cb20-6" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;prev_date&#39;</span>, F.lag(<span class="st">&#39;date_trunc&#39;</span>, offset<span class="op">=</span><span class="dv">1</span>).over(w))</span>
<span id="cb20-7"><a href="gps.html#cb20-7" aria-hidden="true" tabindex="-1"></a>         .where(col(<span class="st">&#39;prev_geom_id&#39;</span>).isNotNull())</span>
<span id="cb20-8"><a href="gps.html#cb20-8" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;change&#39;</span>, F.when(col(<span class="st">&#39;urban/rural&#39;</span>) <span class="op">==</span> col(<span class="st">&#39;prev_urban/rural&#39;</span>), <span class="st">&#39;no change&#39;</span>)</span>
<span id="cb20-9"><a href="gps.html#cb20-9" aria-hidden="true" tabindex="-1"></a>                                .otherwise(F.when(col(<span class="st">&#39;urban/rural&#39;</span>) <span class="op">==</span> <span class="st">&#39;urban&#39;</span>, <span class="st">&#39;rural to urban&#39;</span>)</span>
<span id="cb20-10"><a href="gps.html#cb20-10" aria-hidden="true" tabindex="-1"></a>                                            .otherwise(F.when(col(<span class="st">&#39;urban/rural&#39;</span>) <span class="op">==</span> <span class="st">&#39;rural&#39;</span>, <span class="st">&#39;urban to rural&#39;</span>))))</span>
<span id="cb20-11"><a href="gps.html#cb20-11" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;gap&#39;</span>, F.datediff(col(<span class="st">&#39;date_trunc&#39;</span>), col(<span class="st">&#39;prev_date&#39;</span>)))</span>
<span id="cb20-12"><a href="gps.html#cb20-12" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;rand_gap&#39;</span>, (<span class="op">-</span><span class="dv">1</span><span class="op">*</span>F.rand()<span class="op">*</span>(col(<span class="st">&#39;gap&#39;</span>)<span class="op">-</span><span class="dv">1</span>)).astype(IntegerType()))</span>
<span id="cb20-13"><a href="gps.html#cb20-13" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;new_date&#39;</span>, F.expr(<span class="st">&quot;date_add(date_trunc, rand_gap)&quot;</span>))</span>
<span id="cb20-14"><a href="gps.html#cb20-14" aria-hidden="true" tabindex="-1"></a>         .withColumn(<span class="st">&#39;date_trunc&#39;</span>, col(<span class="st">&#39;new_date&#39;</span>)))</span></code></pre></div>
<p>Finally we only group the number of changes by date and wealth group.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="gps.html#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># aggregate by day and change and return as pandas df</span></span>
<span id="cb21-2"><a href="gps.html#cb21-2" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> (h_stops</span>
<span id="cb21-3"><a href="gps.html#cb21-3" aria-hidden="true" tabindex="-1"></a>     .groupby(<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;wealth_label&#39;</span>, <span class="st">&#39;change&#39;</span>)</span>
<span id="cb21-4"><a href="gps.html#cb21-4" aria-hidden="true" tabindex="-1"></a>     .agg(F.countDistinct(<span class="st">&#39;user_id&#39;</span>).alias(<span class="st">&#39;n_users&#39;</span>))</span>
<span id="cb21-5"><a href="gps.html#cb21-5" aria-hidden="true" tabindex="-1"></a>     .withColumnRenamed(<span class="st">&#39;date_trunc&#39;</span>, <span class="st">&#39;date&#39;</span>)</span>
<span id="cb21-6"><a href="gps.html#cb21-6" aria-hidden="true" tabindex="-1"></a>     .toPandas())</span>
<span id="cb21-7"><a href="gps.html#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="gps.html#cb21-8" aria-hidden="true" tabindex="-1"></a>out[<span class="st">&#39;country&#39;</span>] <span class="op">=</span> country</span></code></pre></div>
<p>Finally, we compute the cumulative percentage change of the difference between the individuals going to rural areas and
the ones to urban areas. This way we get the net rural migration percentage.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:migration-fig"></span>
<img src="big-daa_files/figure-html/migration-fig-1.png" alt="Results for six different cities São Paulo, Bogota, Jakarta, Mexico City, Quezon City (Manila), and Johannesburg. Measuring: Net rural migration in the fraction of people who lived in the city at any point in time. The three coloured lines distinguishes the metric changes for the three different socio-economic groups." width="80%" />
<p class="caption">
Figure 2.5: Results for six different cities São Paulo, Bogota, Jakarta, Mexico City, Quezon City (Manila), and Johannesburg. Measuring: Net rural migration in the fraction of people who lived in the city at any point in time. The three coloured lines distinguishes the metric changes for the three different socio-economic groups.
</p>
</div>

</div>
</div>
<div id="optimization" class="section level2" number="2.7">
<h2><span class="header-section-number">2.7</span> Location labeling and parameter optimization</h2>
<p>One of the crucial steps allowing us to perform the analyses presented in this book is the ability to infer individual home locations and workplaces.
Additional information, based on the individual pattern of visits to recurrent locations, are added to each stop location to distinguish their roles and importance.</p>
<p>This process has been extensively presented in Chapter <a href="gps.html#labeling">2.4</a>. Here, we discuss how we converged on a specific parameter configuration to be shared by all the different countries analysed in the book.</p>
<div id="ground-truth" class="section level3" number="2.7.1">
<h3><span class="header-section-number">2.7.1</span> Ground truth</h3>
<div id="construction" class="section level4" number="2.7.1.1">
<h4><span class="header-section-number">2.7.1.1</span> Construction</h4>
<p>The first element needed to optimize the process is a ground truth to which each labeling output can be compared with. To this extent, we selected a sample of 100 active individuals for each country. Active individuals were randomly selected from six activity-based buckets: High, medium, and low activity during the pre-pandemic period; high, medium, and low activity after the pre-pandemic period (buckets combined the combination of the different class, e.g. high-medium or low-low activity buckets). Activity classification was performed splitting in percentile groups with similar size.</p>
<p>The uniform selection of individuals acroos different activity buckets provided a balanced set of data ensuring algorithmic stability across a differentiated spectra of mobile phone usage. We stress that, even if activity groups were constructed using groups of individuals their stop locations were not aggregated in the same group, but each individual locations were separately and independently subjected to the same validation procedure.</p>
</div>
<div id="validation" class="section level4" number="2.7.1.2">
<h4><span class="header-section-number">2.7.1.2</span> Validation</h4>
<p>After the sampling step, individuals’ stop locations are submitted to a validator whose task is to label locations into three different categories: home location, work location, and others. Validators were allowed to label multiple home locations per individual as well as multiple work locations. Validators were required to use all the information at their disposal (both the maps and the distribution of time spent at locations over time-of-the-day, day-of-the-week, and the day-of-the-year). The stop location of same individuals were submitted to two independent validators simultaneously. The results from the first round of manual labeling were, then, submitted to a third validator responsible of solving conflicts between the first two validators. For each step all the validators were provided with the same information presented in the same way through the dashboard presented in figure.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:groudtruthdashboard-fig"></span>
<img src="big-daa_files/figure-html/groudtruthdashboard-fig-1.png" alt="Screenshot of the dashboard used by the validators to manually assign labels to locations. Validators have two maps sourced from different providers (OpenStreetMap at the top, and GoogleMaps at the bottom) to explore. Both maps provide different point of interest information in support to the decisionmaking. The bottom map also allows the validator to switch to a satellate imagery mode. On the right side of the dashboard, validators are provided with summary information for all the locations visited by the individual. In particular, the average distribution of time-at-location during the daytime is provided at the top. Similarly, the middle panel provide interactive distribution for the weekly patters (distribution of time spent on a given weekday at a specific location), while the bottom right panel provide panel data spanning over the entire 2020 period. Data presented in this figure are synthetic in compliance to the individual privacy preserving guidelines from the data provider." width="80%" />
<p class="caption">
Figure 2.6: Screenshot of the dashboard used by the validators to manually assign labels to locations. Validators have two maps sourced from different providers (OpenStreetMap at the top, and GoogleMaps at the bottom) to explore. Both maps provide different point of interest information in support to the decisionmaking. The bottom map also allows the validator to switch to a satellate imagery mode. On the right side of the dashboard, validators are provided with summary information for all the locations visited by the individual. In particular, the average distribution of time-at-location during the daytime is provided at the top. Similarly, the middle panel provide interactive distribution for the weekly patters (distribution of time spent on a given weekday at a specific location), while the bottom right panel provide panel data spanning over the entire 2020 period. Data presented in this figure are synthetic in compliance to the individual privacy preserving guidelines from the data provider.
</p>
</div>
</div>
</div>
<div id="parameter-optimization" class="section level3" number="2.7.2">
<h3><span class="header-section-number">2.7.2</span> Parameter optimization</h3>
<p>The result of the validation procedure are stored as .csv files for each country containing the label by the first independent validator in the “FirstOpinion” column, the label of the second independent validator in the “SecondOpinion” column, and the final label assigned by the conflict-breaker validator in the “FinalOpinion” column. The final labels were compared with the results of the labeling running the labeling step of the pipeline described in <a href="gps.html#labeling">2.4</a> joining the two over the individual unique identifier.</p>
<p>The labeling results produced by the algorithm were restructured using the following function, which returns a dataframe of containing the individual id, stop location unique (for each individual) identifier, and the label returned by the algorithm.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="gps.html#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_algorithm_labels(<span class="op">**</span>args):</span>
<span id="cb22-2"><a href="gps.html#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb22-3"><a href="gps.html#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">  To load computed labels the following are required:</span></span>
<span id="cb22-4"><a href="gps.html#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">      country:                      country of interest</span></span>
<span id="cb22-5"><a href="gps.html#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co">      home_period_window:           size of the window for home</span></span>
<span id="cb22-6"><a href="gps.html#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">      work_period_window:           size of the window for work</span></span>
<span id="cb22-7"><a href="gps.html#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co">      min_periods_over_window:      minimum days/win_size on which candidate should appear to be labelled as H</span></span>
<span id="cb22-8"><a href="gps.html#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">      min_periods_over_window_work: minimum days/win_size on which candidate should appear to be labelled as W</span></span>
<span id="cb22-9"><a href="gps.html#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">      work_activity_average:        average time spent at work in a day over the window</span></span>
<span id="cb22-10"><a href="gps.html#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">      time_fraction_work:           fraction of user time in records spent at work</span></span>
<span id="cb22-11"><a href="gps.html#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co">      fpath:                        path to the label results (country dependent)</span></span>
<span id="cb22-12"><a href="gps.html#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co">  OUTPUT: dataframe of user_id,cluster_label,AlgorithmOpinion</span></span>
<span id="cb22-13"><a href="gps.html#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb22-14"><a href="gps.html#cb22-14" aria-hidden="true" tabindex="-1"></a>  country<span class="op">=</span>args[<span class="st">&quot;country&quot;</span>]</span>
<span id="cb22-15"><a href="gps.html#cb22-15" aria-hidden="true" tabindex="-1"></a>  home_period_window<span class="op">=</span>args[<span class="st">&quot;home_period_window&quot;</span>]</span>
<span id="cb22-16"><a href="gps.html#cb22-16" aria-hidden="true" tabindex="-1"></a>  work_period_window<span class="op">=</span>args[<span class="st">&quot;work_period_window&quot;</span>]</span>
<span id="cb22-17"><a href="gps.html#cb22-17" aria-hidden="true" tabindex="-1"></a>  min_periods_over_window<span class="op">=</span>args[<span class="st">&quot;min_periods_over_window&quot;</span>]</span>
<span id="cb22-18"><a href="gps.html#cb22-18" aria-hidden="true" tabindex="-1"></a>  min_periods_over_window_work<span class="op">=</span>args[<span class="st">&quot;min_periods_over_window_work&quot;</span>]</span>
<span id="cb22-19"><a href="gps.html#cb22-19" aria-hidden="true" tabindex="-1"></a>  work_activity_average<span class="op">=</span>args[<span class="st">&quot;work_activity_average&quot;</span>]</span>
<span id="cb22-20"><a href="gps.html#cb22-20" aria-hidden="true" tabindex="-1"></a>  time_fraction_work<span class="op">=</span>args[<span class="st">&quot;time_fraction_work&quot;</span>]</span>
<span id="cb22-21"><a href="gps.html#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="gps.html#cb22-22" aria-hidden="true" tabindex="-1"></a>  fname <span class="op">=</span> <span class="ss">f&#39;hpw</span><span class="sc">{</span>home_period_window<span class="sc">}</span><span class="ss">_wpw</span><span class="sc">{</span>work_period_window<span class="sc">}</span><span class="ss">_mpow</span><span class="sc">{</span>min_periods_over_window<span class="sc">}</span><span class="ss">_mpoww</span><span class="sc">{</span>min_periods_over_window_work<span class="sc">}</span><span class="ss">_waa</span><span class="sc">{</span>work_activity_average<span class="sc">}</span><span class="ss">_tfw</span><span class="sc">{</span>time_fraction_work<span class="sc">}</span><span class="ss">_v10.csv&#39;</span></span>
<span id="cb22-23"><a href="gps.html#cb22-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-24"><a href="gps.html#cb22-24" aria-hidden="true" tabindex="-1"></a>  df_hw <span class="op">=</span> pd.read_csv(os.path.join(fpath, fname),usecols<span class="op">=</span>[<span class="st">&quot;user_id&quot;</span>, <span class="st">&quot;location_type&quot;</span>, <span class="st">&quot;cluster_label&quot;</span>])</span>
<span id="cb22-25"><a href="gps.html#cb22-25" aria-hidden="true" tabindex="-1"></a>  df_hw <span class="op">=</span> df_hw[df_hw.cluster_label.notna()]</span>
<span id="cb22-26"><a href="gps.html#cb22-26" aria-hidden="true" tabindex="-1"></a>  df_hw[<span class="st">&#39;location_type&#39;</span>] <span class="op">=</span> df_hw.location_type.fillna(<span class="st">&#39;O&#39;</span>)</span>
<span id="cb22-27"><a href="gps.html#cb22-27" aria-hidden="true" tabindex="-1"></a>  df_hw <span class="op">=</span> df_hw.drop_duplicates().reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-28"><a href="gps.html#cb22-28" aria-hidden="true" tabindex="-1"></a>  df_hw <span class="op">=</span> df_hw[df_hw.location_type<span class="op">!=</span><span class="st">&#39;O&#39;</span>].rename(columns<span class="op">=</span>{<span class="st">&#39;location_type&#39;</span>:<span class="st">&#39;AlgorithmOpinion&#39;</span>})</span>
<span id="cb22-29"><a href="gps.html#cb22-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> df_hw</span></code></pre></div>
<p>The arguments required by this functions are those over which the parameter optimization is performed. In particular, we performed a grid-search optimization for each different combination of the following parameter configurations:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="gps.html#cb23-1" aria-hidden="true" tabindex="-1"></a>iter_params <span class="op">=</span> {</span>
<span id="cb23-2"><a href="gps.html#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;home_period_window&quot;</span>:np.arange(<span class="dv">14</span>,<span class="dv">84</span>,<span class="dv">7</span>),</span>
<span id="cb23-3"><a href="gps.html#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;work_period_window&quot;</span>:np.arange(<span class="dv">14</span>,<span class="dv">84</span>,<span class="dv">7</span>),</span>
<span id="cb23-4"><a href="gps.html#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;min_periods_over_window&quot;</span>:np.around(np.linspace(<span class="fl">0.1</span>, <span class="fl">0.4</span>, <span class="dv">5</span>), decimals<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb23-5"><a href="gps.html#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;min_periods_over_window_work&quot;</span>:np.around(np.linspace(<span class="fl">0.1</span>, <span class="fl">0.4</span>, <span class="dv">5</span>), decimals<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb23-6"><a href="gps.html#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;work_activity_average&quot;</span>:[<span class="dv">1800</span><span class="op">*</span>hours <span class="cf">for</span> hours <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">5</span>)],</span>
<span id="cb23-7"><a href="gps.html#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;time_fraction_work&quot;</span>:[<span class="fl">0.0</span>, <span class="fl">0.2</span>, <span class="fl">0.4</span>, <span class="fl">0.6</span>]</span>
<span id="cb23-8"><a href="gps.html#cb23-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div id="performance-indicators" class="section level4" number="2.7.2.1">
<h4><span class="header-section-number">2.7.2.1</span> Performance indicators</h4>
<p>In the code presented below we provide multiple performance indicators. Each one of those can be used to assess different aspects. For example, the intra-validators agreement can be compared with the average agreement between one of the two “first-step” validators and the algorithm (we do this using the Choen’s kappa statistic) to get a direct comparison between validators and algorithm accord. Focusing on direct performance metrics, we instead use the F1-score computed between the final validator’s opinion and the algorithm result looking for all locations correctly labelled as either “home-location” or “work-location.” The F1-score is computed for each one of the two labels independently and then aggregated averaging the two results.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="gps.html#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># To speed up computations remove all locations labelled as &quot;O&quot; (other) from the data.</span></span>
<span id="cb24-2"><a href="gps.html#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> filter_o(df,col1,col2): <span class="cf">return</span> df[(df[col1]<span class="op">!=</span><span class="st">&#39;O&#39;</span>)<span class="op">|</span>(df[col2]<span class="op">!=</span><span class="st">&#39;O&#39;</span>)]</span>
<span id="cb24-3"><a href="gps.html#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="gps.html#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_sample_metrics(df_sample,col_true,col_eval1):</span>
<span id="cb24-5"><a href="gps.html#cb24-5" aria-hidden="true" tabindex="-1"></a>  a1 <span class="op">=</span> <span class="st">&#39;FirstOpinion&#39;</span></span>
<span id="cb24-6"><a href="gps.html#cb24-6" aria-hidden="true" tabindex="-1"></a>  a2 <span class="op">=</span> <span class="st">&#39;SecondOpinion&#39;</span></span>
<span id="cb24-7"><a href="gps.html#cb24-7" aria-hidden="true" tabindex="-1"></a>  dfte <span class="op">=</span> filter_o(df_sample,col_true,col_eval1)</span>
<span id="cb24-8"><a href="gps.html#cb24-8" aria-hidden="true" tabindex="-1"></a>  df1e <span class="op">=</span> filter_o(df_sample,a1,col_eval1)</span>
<span id="cb24-9"><a href="gps.html#cb24-9" aria-hidden="true" tabindex="-1"></a>  df2e <span class="op">=</span> filter_o(df_sample,a2,col_eval1)</span>
<span id="cb24-10"><a href="gps.html#cb24-10" aria-hidden="true" tabindex="-1"></a>  df12 <span class="op">=</span> filter_o(df_sample,a1,a2)</span>
<span id="cb24-11"><a href="gps.html#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="gps.html#cb24-12" aria-hidden="true" tabindex="-1"></a>  kappa <span class="op">=</span> ((skm.cohen_kappa_score(df1e[a1],df1e[col_eval1], labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>,<span class="st">&#39;W&#39;</span>])<span class="op">+</span></span>
<span id="cb24-13"><a href="gps.html#cb24-13" aria-hidden="true" tabindex="-1"></a>            skm.cohen_kappa_score(df2e[a2],df2e[col_eval1], labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>,<span class="st">&#39;W&#39;</span>]))<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb24-14"><a href="gps.html#cb24-14" aria-hidden="true" tabindex="-1"></a>  accuracy <span class="op">=</span> skm.accuracy_score(dfte[col_true],dfte[col_eval1])</span>
<span id="cb24-15"><a href="gps.html#cb24-15" aria-hidden="true" tabindex="-1"></a>  f1 <span class="op">=</span> skm.f1_score(dfte[col_true],dfte[col_eval1],labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>,<span class="st">&#39;W&#39;</span>],average<span class="op">=</span><span class="st">&#39;macro&#39;</span>)</span>
<span id="cb24-16"><a href="gps.html#cb24-16" aria-hidden="true" tabindex="-1"></a>  f1H <span class="op">=</span> skm.f1_score(dfte[col_true],dfte[col_eval1],labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>],average<span class="op">=</span><span class="st">&#39;macro&#39;</span>)</span>
<span id="cb24-17"><a href="gps.html#cb24-17" aria-hidden="true" tabindex="-1"></a>  f1W <span class="op">=</span> skm.f1_score(dfte[col_true],dfte[col_eval1],labels<span class="op">=</span>[<span class="st">&#39;W&#39;</span>],average<span class="op">=</span><span class="st">&#39;macro&#39;</span>)</span>
<span id="cb24-18"><a href="gps.html#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="gps.html#cb24-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># these are metrics computed one annotator against the other.</span></span>
<span id="cb24-20"><a href="gps.html#cb24-20" aria-hidden="true" tabindex="-1"></a>  kappa_ann <span class="op">=</span> skm.cohen_kappa_score(df12[a1],df12[a2], labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>,<span class="st">&#39;W&#39;</span>])</span>
<span id="cb24-21"><a href="gps.html#cb24-21" aria-hidden="true" tabindex="-1"></a>  accuracy_ann <span class="op">=</span> skm.accuracy_score(df12[a1],df12[a2])</span>
<span id="cb24-22"><a href="gps.html#cb24-22" aria-hidden="true" tabindex="-1"></a>  f1_ann <span class="op">=</span> skm.f1_score(df12[a1],df12[a2],labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>,<span class="st">&#39;W&#39;</span>],average<span class="op">=</span><span class="st">&#39;macro&#39;</span>)</span>
<span id="cb24-23"><a href="gps.html#cb24-23" aria-hidden="true" tabindex="-1"></a>  f1_annH <span class="op">=</span> skm.f1_score(df12[a1],df12[a2],labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>],average<span class="op">=</span><span class="st">&#39;macro&#39;</span>)</span>
<span id="cb24-24"><a href="gps.html#cb24-24" aria-hidden="true" tabindex="-1"></a>  f1_annW <span class="op">=</span> skm.f1_score(df12[a1],df12[a2],labels<span class="op">=</span>[<span class="st">&#39;W&#39;</span>],average<span class="op">=</span><span class="st">&#39;macro&#39;</span>)</span>
<span id="cb24-25"><a href="gps.html#cb24-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-26"><a href="gps.html#cb24-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> {<span class="st">&#39;accuracy&#39;</span>:accuracy,<span class="st">&#39;f1&#39;</span>:f1,<span class="st">&#39;kappa&#39;</span>:kappa,</span>
<span id="cb24-27"><a href="gps.html#cb24-27" aria-hidden="true" tabindex="-1"></a>          <span class="st">&#39;accuracy_ann&#39;</span>:accuracy_ann,<span class="st">&#39;f1_ann&#39;</span>:f1_ann,<span class="st">&#39;kappa_ann&#39;</span>:kappa_ann,</span>
<span id="cb24-28"><a href="gps.html#cb24-28" aria-hidden="true" tabindex="-1"></a>          <span class="st">&#39;f1_annH&#39;</span>:f1_annH,<span class="st">&#39;f1_annW&#39;</span>:f1_annW,<span class="st">&#39;f1_H&#39;</span>:f1H,<span class="st">&#39;f1_W&#39;</span>:f1W}</span></code></pre></div>
</div>
<div id="performance-error-estimates-and-bootstrapping" class="section level4" number="2.7.2.2">
<h4><span class="header-section-number">2.7.2.2</span> Performance error estimates and bootstrapping</h4>
<p>As an estimate for the performance variability induced by the selected sample of individuals we use a standard bootstrapping procedure, resampling with replacement for 100 different times the individuals from those present in the validation set. Resampling is performed in such a way that guarantees the balance across activity-buckets.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="gps.html#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_shuffled_fraction_by_group(df_group,fraction<span class="op">=</span><span class="dv">1</span>,replace<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb25-2"><a href="gps.html#cb25-2" aria-hidden="true" tabindex="-1"></a>  size <span class="op">=</span> <span class="bu">int</span>(df_group.user_id.unique().size<span class="op">*</span>fraction)</span>
<span id="cb25-3"><a href="gps.html#cb25-3" aria-hidden="true" tabindex="-1"></a>  sampled_users <span class="op">=</span> np.random.choice(df_group.user_id.unique(),replace<span class="op">=</span>replace,size <span class="op">=</span> size)</span>
<span id="cb25-4"><a href="gps.html#cb25-4" aria-hidden="true" tabindex="-1"></a>  df_res <span class="op">=</span> df_group.set_index(<span class="st">&#39;user_id&#39;</span>)</span>
<span id="cb25-5"><a href="gps.html#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> df_res.loc[sampled_users].reset_index()</span>
<span id="cb25-6"><a href="gps.html#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="gps.html#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> balanced_bootstrapping(df_man, num_sample<span class="op">=</span><span class="dv">100</span>, metrics<span class="op">=</span><span class="va">True</span>, col_true<span class="op">=</span><span class="st">&#39;FinalOpinion&#39;</span>, col_eval1<span class="op">=</span><span class="st">&#39;FirstOpinion&#39;</span>):</span>
<span id="cb25-8"><a href="gps.html#cb25-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="kw">not</span> metrics: df_res <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>df_man.columns<span class="op">+</span>[<span class="st">&#39;sample&#39;</span>])</span>
<span id="cb25-9"><a href="gps.html#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:           df_res <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">&#39;sample&#39;</span>,<span class="st">&#39;accuracy&#39;</span>,<span class="st">&#39;f1&#39;</span>,<span class="st">&#39;kappa&#39;</span>])</span>
<span id="cb25-10"><a href="gps.html#cb25-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i_sample <span class="kw">in</span> <span class="bu">range</span>(num_sample):</span>
<span id="cb25-11"><a href="gps.html#cb25-11" aria-hidden="true" tabindex="-1"></a>    df_samp_res <span class="op">=</span> df_man.groupby(<span class="st">&#39;act_buck&#39;</span>,as_index<span class="op">=</span><span class="va">False</span>).<span class="bu">apply</span>(sample_shuffled_fraction_by_group).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-12"><a href="gps.html#cb25-12" aria-hidden="true" tabindex="-1"></a>    df_samp_res[<span class="st">&#39;sample&#39;</span>] <span class="op">=</span> i_sample<span class="op">+</span><span class="dv">1</span></span>
<span id="cb25-13"><a href="gps.html#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> metrics: df_res <span class="op">=</span> df_res.append(df_samp_res)</span>
<span id="cb25-14"><a href="gps.html#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:           df_res <span class="op">=</span> df_res.append({<span class="st">&#39;sample&#39;</span>:i_sample<span class="op">+</span><span class="dv">1</span>,<span class="op">**</span>compute_sample_metrics(df_samp_res,col_true,col_eval1)},ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-15"><a href="gps.html#cb25-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> df_res</span></code></pre></div>
<p>For each parameter configuration bootstrap is performed and results are structured and stored in the form of a dictionary.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="gps.html#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_multi_config_metrics(<span class="op">**</span>args):</span>
<span id="cb26-2"><a href="gps.html#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Initialize variables from passed &quot;args&quot; dict</span></span>
<span id="cb26-3"><a href="gps.html#cb26-3" aria-hidden="true" tabindex="-1"></a>  country<span class="op">=</span>args[<span class="st">&quot;country&quot;</span>]</span>
<span id="cb26-4"><a href="gps.html#cb26-4" aria-hidden="true" tabindex="-1"></a>  manual_labels<span class="op">=</span>args[<span class="st">&quot;manual_labels&quot;</span>]</span>
<span id="cb26-5"><a href="gps.html#cb26-5" aria-hidden="true" tabindex="-1"></a>  act_buckets <span class="op">=</span> args[<span class="st">&#39;activity_bucket&#39;</span>]</span>
<span id="cb26-6"><a href="gps.html#cb26-6" aria-hidden="true" tabindex="-1"></a>  df_hw <span class="op">=</span> get_algorithm_labels(<span class="op">**</span>args)</span>
<span id="cb26-7"><a href="gps.html#cb26-7" aria-hidden="true" tabindex="-1"></a>  df_hw[<span class="st">&#39;act_buck&#39;</span>] <span class="op">=</span> df_hw.user_id.<span class="bu">map</span>(act_buckets)</span>
<span id="cb26-8"><a href="gps.html#cb26-8" aria-hidden="true" tabindex="-1"></a>  col_true <span class="op">=</span> args[<span class="st">&#39;col_true&#39;</span>]</span>
<span id="cb26-9"><a href="gps.html#cb26-9" aria-hidden="true" tabindex="-1"></a>  col_eval1 <span class="op">=</span> args[<span class="st">&#39;col_eval1&#39;</span>]</span>
<span id="cb26-10"><a href="gps.html#cb26-10" aria-hidden="true" tabindex="-1"></a>  col_eval2 <span class="op">=</span> args[<span class="st">&#39;col_eval2&#39;</span>]</span>
<span id="cb26-11"><a href="gps.html#cb26-11" aria-hidden="true" tabindex="-1"></a>  numer_of_samples <span class="op">=</span> args[<span class="st">&#39;numer_of_samples&#39;</span>]</span>
<span id="cb26-12"><a href="gps.html#cb26-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-13"><a href="gps.html#cb26-13" aria-hidden="true" tabindex="-1"></a>  df_compare <span class="op">=</span> (pd.merge(manual_labels, df_hw, how<span class="op">=</span><span class="st">&quot;outer&quot;</span>, on<span class="op">=</span>[<span class="st">&quot;user_id&quot;</span>, <span class="st">&quot;cluster_label&quot;</span>,<span class="st">&quot;act_buck&quot;</span>])</span>
<span id="cb26-14"><a href="gps.html#cb26-14" aria-hidden="true" tabindex="-1"></a>                .sort_values(by<span class="op">=</span>[<span class="st">&quot;user_id&quot;</span>,<span class="st">&quot;cluster_label&quot;</span>,<span class="st">&quot;FinalOpinion&quot;</span>,<span class="st">&quot;AlgorithmOpinion&quot;</span>])</span>
<span id="cb26-15"><a href="gps.html#cb26-15" aria-hidden="true" tabindex="-1"></a>                .drop_duplicates(subset<span class="op">=</span>[<span class="st">&quot;user_id&quot;</span>,<span class="st">&quot;cluster_label&quot;</span>])</span>
<span id="cb26-16"><a href="gps.html#cb26-16" aria-hidden="true" tabindex="-1"></a>                .reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb26-17"><a href="gps.html#cb26-17" aria-hidden="true" tabindex="-1"></a>                .fillna({<span class="st">&#39;Country&#39;</span>:country,<span class="st">&#39;FirstOpinion&#39;</span>:<span class="st">&#39;O&#39;</span>,<span class="st">&#39;SecondOpinion&#39;</span>:<span class="st">&#39;O&#39;</span>,<span class="st">&#39;AlgorithmOpinion&#39;</span>:<span class="st">&#39;O&#39;</span>,<span class="st">&#39;FinalOpinion&#39;</span>:<span class="st">&#39;O&#39;</span>}))</span>
<span id="cb26-18"><a href="gps.html#cb26-18" aria-hidden="true" tabindex="-1"></a>  df_compare <span class="op">=</span> df_compare[(df_compare.FinalOpinion<span class="op">!=</span><span class="st">&#39;O&#39;</span>)<span class="op">|</span>(df_compare.AlgorithmOpinion<span class="op">!=</span><span class="st">&#39;O&#39;</span>)]</span>
<span id="cb26-19"><a href="gps.html#cb26-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-20"><a href="gps.html#cb26-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute performance metrics</span></span>
<span id="cb26-21"><a href="gps.html#cb26-21" aria-hidden="true" tabindex="-1"></a>  accuracy <span class="op">=</span> skm.accuracy_score(df_compare[col_true], df_compare[col_eval1])</span>
<span id="cb26-22"><a href="gps.html#cb26-22" aria-hidden="true" tabindex="-1"></a>  kappa <span class="op">=</span> (skm.cohen_kappa_score(df_compare[<span class="st">&#39;FirstOpinion&#39;</span>], df_compare[col_eval1])<span class="op">+</span>skm.cohen_kappa_score(df_compare[<span class="st">&#39;SecondOpinion&#39;</span>], df_compare[col_eval1]))<span class="op">/</span><span class="dv">2</span></span>
<span id="cb26-23"><a href="gps.html#cb26-23" aria-hidden="true" tabindex="-1"></a>  recall <span class="op">=</span> skm.recall_score(df_compare[col_true], df_compare[col_eval1],labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>,<span class="st">&#39;W&#39;</span>], average<span class="op">=</span><span class="st">&quot;macro&quot;</span>)</span>
<span id="cb26-24"><a href="gps.html#cb26-24" aria-hidden="true" tabindex="-1"></a>  precision <span class="op">=</span> skm.precision_score(df_compare[col_true], df_compare[col_eval1],labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>,<span class="st">&#39;W&#39;</span>], average<span class="op">=</span><span class="st">&quot;macro&quot;</span>)</span>
<span id="cb26-25"><a href="gps.html#cb26-25" aria-hidden="true" tabindex="-1"></a>  f1 <span class="op">=</span> skm.f1_score(df_compare[col_true], df_compare[col_eval1],labels<span class="op">=</span>[<span class="st">&#39;H&#39;</span>,<span class="st">&#39;W&#39;</span>], average<span class="op">=</span><span class="st">&quot;macro&quot;</span>)</span>
<span id="cb26-26"><a href="gps.html#cb26-26" aria-hidden="true" tabindex="-1"></a>  cf <span class="op">=</span> skm.confusion_matrix(df_compare[col_true], df_compare[col_eval1])</span>
<span id="cb26-27"><a href="gps.html#cb26-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-28"><a href="gps.html#cb26-28" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Estimate performance errors via Bootstrapping</span></span>
<span id="cb26-29"><a href="gps.html#cb26-29" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> balanced_bootstrapping(df_compare,num_sample<span class="op">=</span>numer_of_samples,col_true<span class="op">=</span>col_true,col_eval1<span class="op">=</span>col_eval1)</span>
<span id="cb26-30"><a href="gps.html#cb26-30" aria-hidden="true" tabindex="-1"></a>  m <span class="op">=</span> res.mean().iloc[<span class="dv">1</span>:]</span>
<span id="cb26-31"><a href="gps.html#cb26-31" aria-hidden="true" tabindex="-1"></a>  m <span class="op">=</span> m.sort_index()</span>
<span id="cb26-32"><a href="gps.html#cb26-32" aria-hidden="true" tabindex="-1"></a>  m.index<span class="op">=</span>[<span class="st">&#39;fold_acc&#39;</span>,<span class="st">&#39;fold_annotators_acc&#39;</span>,<span class="st">&#39;fold_f1&#39;</span>,<span class="st">&#39;fold_f1H&#39;</span>,<span class="st">&#39;fold_f1W&#39;</span>,<span class="st">&#39;fold_annotators_f1&#39;</span>,<span class="st">&#39;fold_annotators_f1H&#39;</span>,<span class="st">&#39;fold_annotators_f1W&#39;</span>,<span class="st">&#39;fold_kap&#39;</span>,<span class="st">&#39;fold_annotators_kap&#39;</span>]</span>
<span id="cb26-33"><a href="gps.html#cb26-33" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> res.std().iloc[<span class="dv">1</span>:]</span>
<span id="cb26-34"><a href="gps.html#cb26-34" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> s.sort_index()</span>
<span id="cb26-35"><a href="gps.html#cb26-35" aria-hidden="true" tabindex="-1"></a>  s.index<span class="op">=</span>[<span class="st">&#39;fold_acc_std&#39;</span>,<span class="st">&#39;fold_annotators_acc_std&#39;</span>,<span class="st">&#39;fold_f1_std&#39;</span>,<span class="st">&#39;fold_f1H_std&#39;</span>,<span class="st">&#39;fold_f1W_std&#39;</span>,<span class="st">&#39;fold_annotators_f1_std&#39;</span>,<span class="st">&#39;fold_annotators_f1H_std&#39;</span>,<span class="st">&#39;fold_annotators_f1W_std&#39;</span>,<span class="st">&#39;fold_kap_std&#39;</span>,<span class="st">&#39;fold_annotators_kap_std&#39;</span>]</span>
<span id="cb26-36"><a href="gps.html#cb26-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-37"><a href="gps.html#cb26-37" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Collect and structure results into a dictionary</span></span>
<span id="cb26-38"><a href="gps.html#cb26-38" aria-hidden="true" tabindex="-1"></a>  the_dict <span class="op">=</span> {<span class="st">&quot;country&quot;</span>:country,</span>
<span id="cb26-39"><a href="gps.html#cb26-39" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;home_period_window&quot;</span>:<span class="bu">int</span>(args[<span class="st">&#39;home_period_window&#39;</span>]),</span>
<span id="cb26-40"><a href="gps.html#cb26-40" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;work_period_window&quot;</span>:<span class="bu">int</span>(args[<span class="st">&#39;work_period_window&#39;</span>]),</span>
<span id="cb26-41"><a href="gps.html#cb26-41" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;min_periods_over_window&quot;</span>:<span class="bu">float</span>(args[<span class="st">&#39;min_periods_over_window&#39;</span>]),</span>
<span id="cb26-42"><a href="gps.html#cb26-42" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;min_periods_over_window_work&quot;</span>:<span class="bu">float</span>(args[<span class="st">&#39;min_periods_over_window_work&#39;</span>]),</span>
<span id="cb26-43"><a href="gps.html#cb26-43" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;work_activity_average&quot;</span>:<span class="bu">float</span>(args[<span class="st">&#39;work_activity_average&#39;</span>]),</span>
<span id="cb26-44"><a href="gps.html#cb26-44" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;time_fraction_work&quot;</span>:<span class="bu">float</span>(args[<span class="st">&#39;time_fraction_work&#39;</span>]),</span>
<span id="cb26-45"><a href="gps.html#cb26-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-46"><a href="gps.html#cb26-46" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;f1&quot;</span>:f1,<span class="st">&quot;accuracy&quot;</span>:accuracy,<span class="st">&quot;kappa&quot;</span>:kappa,</span>
<span id="cb26-47"><a href="gps.html#cb26-47" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;cf&quot;</span>:cf,<span class="op">**</span>m,<span class="op">**</span>s}</span>
<span id="cb26-48"><a href="gps.html#cb26-48" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> the_dict</span></code></pre></div>
</div>
<div id="parallel-bootstrapping-and-optimization-result-storage" class="section level4" number="2.7.2.3">
<h4><span class="header-section-number">2.7.2.3</span> Parallel bootstrapping and optimization result storage</h4>
<p>The enormous number of combination of parameter configuration we have to explore can be speeded up by multiprocess computation of the different configurations. Here, we present a possible solution which uses the [python “joblib” library]{<a href="https://joblib.readthedocs.io/en/latest/" class="uri">https://joblib.readthedocs.io/en/latest/</a>}.
Parameter configurations are stored as a list of dictionaries which is then passed to the “Parallel” function.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="gps.html#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> joblib <span class="im">import</span> Parallel,delayed</span>
<span id="cb27-2"><a href="gps.html#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="gps.html#cb27-3" aria-hidden="true" tabindex="-1"></a>results_save_path <span class="op">=</span> <span class="st">&quot;SAVING_PATH_FOR_CONFIGURATION_PERFORMANCE_EVALUTATION&quot;</span></span>
<span id="cb27-4"><a href="gps.html#cb27-4" aria-hidden="true" tabindex="-1"></a>numer_of_samples <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb27-5"><a href="gps.html#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="gps.html#cb27-6" aria-hidden="true" tabindex="-1"></a>c_dates <span class="op">=</span> {<span class="st">&#39;BR&#39;</span>: <span class="st">&#39;2021-01-01&#39;</span>, <span class="st">&#39;CO&#39;</span>: <span class="st">&#39;2021-01-01&#39;</span>, <span class="st">&#39;ID&#39;</span>: <span class="st">&#39;2021-01-01&#39;</span>,</span>
<span id="cb27-7"><a href="gps.html#cb27-7" aria-hidden="true" tabindex="-1"></a>           <span class="st">&#39;ZA&#39;</span>: <span class="st">&#39;2021-01-01&#39;</span>, <span class="st">&#39;MX&#39;</span>: <span class="st">&#39;2020-12-01&#39;</span>, <span class="st">&#39;PH&#39;</span>: <span class="st">&#39;2021-01-01&#39;</span>}</span>
<span id="cb27-8"><a href="gps.html#cb27-8" aria-hidden="true" tabindex="-1"></a>countries <span class="op">=</span> [<span class="st">&#39;CO&#39;</span>,<span class="st">&#39;PH&#39;</span>,<span class="st">&#39;MX&#39;</span>,<span class="st">&#39;BR&#39;</span>,<span class="st">&#39;ID&#39;</span>]</span>
<span id="cb27-9"><a href="gps.html#cb27-9" aria-hidden="true" tabindex="-1"></a>result_list <span class="op">=</span> []</span>
<span id="cb27-10"><a href="gps.html#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> country <span class="kw">in</span> countries:</span>
<span id="cb27-11"><a href="gps.html#cb27-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(country)</span>
<span id="cb27-12"><a href="gps.html#cb27-12" aria-hidden="true" tabindex="-1"></a>  df_man <span class="op">=</span>  get_labels(country)</span>
<span id="cb27-13"><a href="gps.html#cb27-13" aria-hidden="true" tabindex="-1"></a>  activity_bucket <span class="op">=</span> df_man.drop_duplicates([<span class="st">&#39;user_id&#39;</span>,<span class="st">&#39;act_buck&#39;</span>]).set_index(<span class="st">&#39;user_id&#39;</span>).act_buck.dropna().to_dict()</span>
<span id="cb27-14"><a href="gps.html#cb27-14" aria-hidden="true" tabindex="-1"></a>  init_params <span class="op">=</span> {<span class="st">&quot;country&quot;</span>:[country],<span class="st">&quot;c_dates&quot;</span>:[c_dates]}</span>
<span id="cb27-15"><a href="gps.html#cb27-15" aria-hidden="true" tabindex="-1"></a>  parameters <span class="op">=</span> {<span class="op">**</span>init_params, <span class="op">**</span>iter_params}</span>
<span id="cb27-16"><a href="gps.html#cb27-16" aria-hidden="true" tabindex="-1"></a>  additional_params <span class="op">=</span> {<span class="st">&quot;numer_of_samples&quot;</span>:numer_of_samples,<span class="st">&quot;activity_bucket&quot;</span>:activity_bucket,<span class="st">&quot;manual_labels&quot;</span>:df_man,</span>
<span id="cb27-17"><a href="gps.html#cb27-17" aria-hidden="true" tabindex="-1"></a>                       <span class="st">&#39;col_true&#39;</span>:<span class="st">&#39;FinalOpinion&#39;</span>,<span class="st">&#39;col_eval1&#39;</span>:<span class="st">&#39;AlgorithmOpinion&#39;</span>,<span class="st">&#39;col_eval2&#39;</span>:<span class="va">None</span>}</span>
<span id="cb27-18"><a href="gps.html#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="gps.html#cb27-19" aria-hidden="true" tabindex="-1"></a>  results_df <span class="op">=</span> pd.DataFrame(columns<span class="op">=</span>[<span class="st">&quot;country&quot;</span>, <span class="st">&quot;home_period_window&quot;</span>, <span class="st">&quot;work_period_window&quot;</span>, <span class="st">&quot;min_periods_over_window&quot;</span>, <span class="st">&quot;min_periods_over_window_work&quot;</span>, <span class="st">&quot;work_activity_average&quot;</span>, <span class="st">&quot;time_fraction_work&quot;</span>, <span class="st">&quot;accuracy&quot;</span>, <span class="st">&quot;recall&quot;</span>, <span class="st">&quot;precision&quot;</span>, <span class="st">&quot;f1&quot;</span>, <span class="st">&quot;fold_f1&quot;</span>,<span class="st">&quot;fold_acc&quot;</span>,<span class="st">&quot;fold_kap&quot;</span>,<span class="st">&quot;fold_f1_sem&quot;</span>,<span class="st">&quot;fold_acc_sem&quot;</span>,<span class="st">&quot;fold_kap_sem&quot;</span>, <span class="st">&quot;cf&quot;</span>])</span>
<span id="cb27-20"><a href="gps.html#cb27-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-21"><a href="gps.html#cb27-21" aria-hidden="true" tabindex="-1"></a>  keys <span class="op">=</span> <span class="bu">list</span>(parameters)</span>
<span id="cb27-22"><a href="gps.html#cb27-22" aria-hidden="true" tabindex="-1"></a>  keyvals <span class="op">=</span> []</span>
<span id="cb27-23"><a href="gps.html#cb27-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> values <span class="kw">in</span> itertools.product(<span class="op">*</span><span class="bu">map</span>(parameters.get, keys)):</span>
<span id="cb27-24"><a href="gps.html#cb27-24" aria-hidden="true" tabindex="-1"></a>    keyval <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(keys, values))</span>
<span id="cb27-25"><a href="gps.html#cb27-25" aria-hidden="true" tabindex="-1"></a>    keyval <span class="op">=</span> {k:<span class="bu">str</span>(v) <span class="cf">for</span> k, v <span class="kw">in</span> keyval.items()}</span>
<span id="cb27-26"><a href="gps.html#cb27-26" aria-hidden="true" tabindex="-1"></a>    keyval <span class="op">=</span> {<span class="op">**</span>keyval,<span class="op">**</span>additional_params}</span>
<span id="cb27-27"><a href="gps.html#cb27-27" aria-hidden="true" tabindex="-1"></a>    keyvals.append(keyval)</span>
<span id="cb27-28"><a href="gps.html#cb27-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-29"><a href="gps.html#cb27-29" aria-hidden="true" tabindex="-1"></a>  result_list <span class="op">+=</span> Parallel(n_jobs<span class="op">=</span><span class="dv">32</span>)(delayed(get_multi_config_metrics)(<span class="op">**</span>keyval) <span class="cf">for</span> j,keyval <span class="kw">in</span> <span class="bu">enumerate</span>(keyvals[:]))</span>
<span id="cb27-30"><a href="gps.html#cb27-30" aria-hidden="true" tabindex="-1"></a>results_df <span class="op">=</span> pd.DataFrame.from_records(result_list)</span>
<span id="cb27-31"><a href="gps.html#cb27-31" aria-hidden="true" tabindex="-1"></a>results_df[<span class="st">&#39;samples&#39;</span>] <span class="op">=</span> numer_of_samples</span>
<span id="cb27-32"><a href="gps.html#cb27-32" aria-hidden="true" tabindex="-1"></a>results_df.to_csv(results_save_path<span class="op">+</span><span class="ss">f&quot;final_statistics_with_</span><span class="sc">{</span>numer_of_samples<span class="sc">}</span><span class="ss">_folding_v10.csv&quot;</span>, index<span class="op">=</span><span class="va">False</span>)</span></code></pre></div>
</div>
</div>
<div id="parameter-configuration-selection" class="section level3" number="2.7.3">
<h3><span class="header-section-number">2.7.3</span> Parameter configuration selection</h3>
<p>While for each country a different optimal configuration can be found, leveraging over the performance error estimates, it is possible to check for common configuartions across different countries which are compatible (i.e. the difference between the optimal configuration F1 minus its standard deviation is smaller than the shared configuration plus its standard deviation) with the country specific best configuration. Best configuration is selected among those compatible for all states by means of the harmonic average of each country F1 score.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="gps.html#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_country_compatibilities(res_country):</span>
<span id="cb28-2"><a href="gps.html#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&#39;&#39;&#39;</span></span>
<span id="cb28-3"><a href="gps.html#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">    INPUT:  pandas dataframe resulting from bootstrapped optimization</span></span>
<span id="cb28-4"><a href="gps.html#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">    OUTPUT: pandas dataframe filtered to keep only configurations which are compatible with the best one</span></span>
<span id="cb28-5"><a href="gps.html#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">  &#39;&#39;&#39;</span></span>
<span id="cb28-6"><a href="gps.html#cb28-6" aria-hidden="true" tabindex="-1"></a>  arg_max <span class="op">=</span> res_country.loc[res_country.fold_f1.idxmax()]</span>
<span id="cb28-7"><a href="gps.html#cb28-7" aria-hidden="true" tabindex="-1"></a>  results_df_fold_f1_max <span class="op">=</span> arg_max.fold_f1</span>
<span id="cb28-8"><a href="gps.html#cb28-8" aria-hidden="true" tabindex="-1"></a>  results_df_fold_f1_mstd <span class="op">=</span> arg_max.fold_f1_std</span>
<span id="cb28-9"><a href="gps.html#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> res_country[res_country.fold_f1<span class="op">+</span>res_country.fold_f1_std<span class="op">&gt;=</span>results_df_fold_f1_max<span class="op">-</span>results_df_fold_f1_mstd]</span></code></pre></div>
<p>We report here, an example to get (if any) a common best parameter configuration for five different countries, namely, Mexico, Brazil, Indonesia, Philippines, and Colombia.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="gps.html#cb29-1" aria-hidden="true" tabindex="-1"></a>countries <span class="op">=</span> [<span class="st">&#39;MX&#39;</span>,<span class="st">&#39;BR&#39;</span>,<span class="st">&#39;ID&#39;</span>,<span class="st">&#39;PH&#39;</span>,<span class="st">&#39;CO&#39;</span>]</span>
<span id="cb29-2"><a href="gps.html#cb29-2" aria-hidden="true" tabindex="-1"></a>numer_of_samples <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb29-3"><a href="gps.html#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="gps.html#cb29-4" aria-hidden="true" tabindex="-1"></a>results_df <span class="op">=</span> pd.read_csv(results_save_path<span class="op">+</span><span class="ss">f&quot;final_statistics_with_</span><span class="sc">{</span>numer_of_samples<span class="sc">}</span><span class="ss">_folding_v10.csv&quot;</span>)</span>
<span id="cb29-5"><a href="gps.html#cb29-5" aria-hidden="true" tabindex="-1"></a>res_opt <span class="op">=</span> results_df.groupby(<span class="st">&#39;country&#39;</span>,as_index<span class="op">=</span><span class="va">False</span>).<span class="bu">apply</span>(get_country_compatibilities)</span>
<span id="cb29-6"><a href="gps.html#cb29-6" aria-hidden="true" tabindex="-1"></a>res_opt <span class="op">=</span> res_opt.set_index([<span class="st">&#39;country&#39;</span>,<span class="st">&quot;home_period_window&quot;</span>,<span class="st">&quot;work_period_window&quot;</span>,</span>
<span id="cb29-7"><a href="gps.html#cb29-7" aria-hidden="true" tabindex="-1"></a>                             <span class="st">&quot;min_periods_over_window&quot;</span>,<span class="st">&quot;min_periods_over_window_work&quot;</span>,</span>
<span id="cb29-8"><a href="gps.html#cb29-8" aria-hidden="true" tabindex="-1"></a>                             <span class="st">&quot;work_activity_average&quot;</span>,<span class="st">&quot;time_fraction_work&quot;</span>])</span>
<span id="cb29-9"><a href="gps.html#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="gps.html#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="co">### Find the best common optimum (optimization function is the max of the average f1 score)</span></span>
<span id="cb29-11"><a href="gps.html#cb29-11" aria-hidden="true" tabindex="-1"></a>res_tmp <span class="op">=</span> results_df.drop_duplicates([<span class="st">&quot;country&quot;</span>,<span class="st">&quot;home_period_window&quot;</span>, <span class="st">&quot;work_period_window&quot;</span>, <span class="st">&quot;min_periods_over_window&quot;</span>, <span class="st">&quot;min_periods_over_window_work&quot;</span>, <span class="st">&quot;work_activity_average&quot;</span>,<span class="st">&quot;time_fraction_work&quot;</span>])</span>
<span id="cb29-12"><a href="gps.html#cb29-12" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> res_tmp.groupby([<span class="st">&quot;home_period_window&quot;</span>, <span class="st">&quot;work_period_window&quot;</span>, <span class="st">&quot;min_periods_over_window&quot;</span>, <span class="st">&quot;min_periods_over_window_work&quot;</span>, <span class="st">&quot;work_activity_average&quot;</span>,<span class="st">&quot;time_fraction_work&quot;</span>]).mean()</span>
<span id="cb29-13"><a href="gps.html#cb29-13" aria-hidden="true" tabindex="-1"></a>res[<span class="st">&#39;fold_f1_harmonic&#39;</span>] <span class="op">=</span> res_tmp.groupby([<span class="st">&quot;home_period_window&quot;</span>, <span class="st">&quot;work_period_window&quot;</span>, <span class="st">&quot;min_periods_over_window&quot;</span>, <span class="st">&quot;min_periods_over_window_work&quot;</span>, <span class="st">&quot;work_activity_average&quot;</span>,<span class="st">&quot;time_fraction_work&quot;</span>]).fold_f1.<span class="bu">apply</span>(hmean)</span>
<span id="cb29-14"><a href="gps.html#cb29-14" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> res.sort_values(<span class="st">&#39;fold_f1_harmonic&#39;</span>,ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb29-15"><a href="gps.html#cb29-15" aria-hidden="true" tabindex="-1"></a>res.reset_index(inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb29-16"><a href="gps.html#cb29-16" aria-hidden="true" tabindex="-1"></a>i<span class="op">=</span><span class="dv">0</span></span>
<span id="cb29-17"><a href="gps.html#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb29-18"><a href="gps.html#cb29-18" aria-hidden="true" tabindex="-1"></a>    test_index <span class="op">=</span> res.iloc[i][[<span class="st">&quot;home_period_window&quot;</span>, <span class="st">&quot;work_period_window&quot;</span>, <span class="st">&quot;min_periods_over_window&quot;</span>, <span class="st">&quot;min_periods_over_window_work&quot;</span>, <span class="st">&quot;work_activity_average&quot;</span>,<span class="st">&quot;time_fraction_work&quot;</span>]].tolist()</span>
<span id="cb29-19"><a href="gps.html#cb29-19" aria-hidden="true" tabindex="-1"></a>    testing<span class="op">=</span>[]</span>
<span id="cb29-20"><a href="gps.html#cb29-20" aria-hidden="true" tabindex="-1"></a>    j<span class="op">=</span><span class="dv">0</span></span>
<span id="cb29-21"><a href="gps.html#cb29-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> country <span class="kw">in</span> countries:</span>
<span id="cb29-22"><a href="gps.html#cb29-22" aria-hidden="true" tabindex="-1"></a>      test <span class="op">=</span> <span class="bu">tuple</span>([country]<span class="op">+</span>test_index)</span>
<span id="cb29-23"><a href="gps.html#cb29-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> test <span class="kw">in</span> res_opt.index.tolist(): j<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb29-24"><a href="gps.html#cb29-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> j <span class="op">==</span> <span class="bu">len</span>(countries):        <span class="bu">print</span>(<span class="ss">f&quot;Best common config found: </span><span class="sc">{i}</span><span class="ss">: </span><span class="sc">{</span>test_index<span class="sc">}</span><span class="ss">&quot;</span>)<span class="op">;</span> <span class="cf">break</span></span>
<span id="cb29-25"><a href="gps.html#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: i<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb29-26"><a href="gps.html#cb29-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i<span class="op">&gt;</span><span class="dv">10000</span>: <span class="bu">print</span>(<span class="st">&#39;Maximum iterations Exceeded. No common optimum found, increase/modify acceptance region!&#39;</span>)<span class="op">;</span> <span class="cf">break</span></span></code></pre></div>
<p>In our case, the best common configiguration found is:
- home_period_window: 49.0,
- work_period_window: 49.0,
- min_periods_over_window: 0.2,
- min_periods_over_window_work: 0.2,
- work_activity_average: 3600.0,
- time_fraction_work: 0.0</p>
<p>These values are the one used to label the locations in the analysis presented in the book.</p>

</div>
</div>
<div id="part-appendix" class="section level2 unnumbered">
<h2>(PART*) Appendix</h2>
</div>
<div id="windex" class="section level2" number="2.8">
<h2><span class="header-section-number">2.8</span> Wealth Index</h2>
<p>In order to explain how the Wealth Index was built we’re going to exemplify
the methodology used for Mexico. For the rest of the countries it was
an analogous procedure, but the variables names are different.</p>
<div id="variables-to-estimate-the-social-gap-index-in-mexico" class="section level3" number="2.8.1">
<h3><span class="header-section-number">2.8.1</span> Variables to estimate the Social Gap Index in Mexico</h3>
<p>To estimate the “Social Gap Index” for Mexico at localidad level, we followed the methodology
of Coneval (National Council of Social Policy Evaluation) in Mexico.
This methodology creates a unique indicator of wealth by reducing the dimensions of a vector of
characteristics related to education, health, basic services and quality of home infrastructure.
To do this, we used principal components using the following variables:</p>
<ul>
<li><strong>Education</strong>
<ul>
<li>Percentage of illiterate population aged 15 or more</li>
<li>Percentage of population aged 6-14 that does not attend to school</li>
<li>Percentage of population aged 15 or more years without complete elementary school</li>
</ul></li>
<li><strong>Health services access</strong>
<ul>
<li>Percentage of population with no access to health services</li>
</ul></li>
<li><strong>Household characteristics</strong>
<ul>
<li>Log of average occupants per room</li>
<li>Percentage of with dirt floor</li>
<li>Percentage of households with no toilet</li>
<li>Percentage of households with no piped water</li>
<li>Percentage of households with no sewer system</li>
<li>Percentage of households with no electricity</li>
<li>Percentage of households with no washing machine</li>
<li>Percentage of inhabited private households with no fridge</li>
</ul></li>
</ul>
<p>Then, we estimated the variables of interest as follows:</p>
</div>
<div id="education" class="section level3" number="2.8.2">
<h3><span class="header-section-number">2.8.2</span> Education</h3>
<ul>
<li><p><strong>Percentage of illiterate population aged 15 or more</strong></p>
<ul>
<li>p15ym_an: Population 15-130 years old who cannot read or write</li>
<li>p_15ymas: Total population older than 15</li>
</ul>
<p><strong>illiterate = p15ym_an/p_15ymas x 100</strong></p></li>
<li><p><strong>Percentage of population aged 6-14 that does not attend school</strong></p>
<ul>
<li>p6a11_noa: Population aged 6-11 that do not attend to school</li>
<li>p12a14noa: Population aged 12-14 that do not attend to school</li>
<li>p_6a11: Population aged 6-11</li>
<li>p_12a14: Population aged 12-14</li>
</ul>
<p><strong>not_attend_school = (p6a11_noa + p12a14noa)/ (p_6a11 + p_12a14) x 100</strong></p></li>
<li><p><strong>Percentage of population aged &gt; 15 years old without full primary education</strong></p>
<ul>
<li><p>p15pri_in: Population 15-130 years old who completed 5th grade as maximum. It includes people who did not specify the grade passed in the this education level</p></li>
<li><p>p15pri_co: Population 15-130 years old who completed 6th grade as maximum. It includes people who did not specify the grade passed in the this education level</p></li>
<li><p>p15ym_se: Population 15-130 who do not passed any grade of schooling or that only have pre-school</p></li>
<li><p>p15sec_in: Population 15-130 years old who did not complete secondary school</p></li>
<li><p>p_15ymas: Total population older than 15</p>
<p><strong>no_primary_educ = p15pri_in+ p15pri_co + p15ym_se + p15sec_in / p_15ymas x 100</strong></p></li>
</ul></li>
</ul>
<div id="health-services-access" class="section level4" number="2.8.2.1">
<h4><span class="header-section-number">2.8.2.1</span> Health Services Access</h4>
<ul>
<li><strong>Percentage of population with no access to health services</strong>
<ul>
<li>p_sinder: Total population who are not entitled to receive medical services in any public or private institution</li>
<li>pobtot: Total population</li>
</ul>
<strong>no_access_health = psinder/pobtot x 100</strong></li>
</ul>
</div>
</div>
<div id="household-characteristics" class="section level3" number="2.8.3">
<h3><span class="header-section-number">2.8.3</span> Household Characteristics</h3>
<ul>
<li><p><strong>Percentage of Households with dirt floor</strong></p>
<ul>
<li>vph_pisodt: Households with dirt floor. It includes households for which the characteristics of the house were captured, classified as independent house, apartment in building, housing or room in neighborhood and housing or rooftop room and to which they did not specify housing class</li>
<li>vivpar_hab: Total inhabited homes.</li>
</ul>
<p><strong>dirt_floor = vph_pisodt/ vivpar_hab x 100</strong></p></li>
<li><p><strong>Average occupants per room</strong>
Result of dividing the number of people residing in inhabited homes by the number of rooms in those homes.</p>
<p><strong>LOG(pro_ocup_c)</strong>
It includes households for which the characteristics of the house were captured, classified as an independent house, apartment in building, housing or room in neighborhood and housing or rooftop room and to which they did not specify housing class.</p></li>
<li><p><strong>Percentage of homes with no toilet</strong></p>
<ul>
<li>vph_excsa: Total number of homes with toilet.</li>
<li>vivpar_hab: Total inhabited homes.</li>
</ul>
<p><strong>no_toilet = 1 - (vph_excsa)/(vivpar_hab) x 100</strong></p></li>
<li><p><strong>Percentage of homes with no piped water</strong></p>
<ul>
<li>vph_aguafv: Households that have water availability from a public or hydrant tap, anotherdwelling, a pipe, a well, a river, a stream, a lake or another. It includes households for which the characteristics of the house were captured, classified as an independent house, apartment in building, housing or room in neighborhood and housing or rooftop room and to which they did not specify housing class.</li>
<li>vivpar_hab: Total inhabited homes</li>
</ul>
<p><strong>no_water = (vph_aguafv) /(vivpar_hab) x 100</strong></p></li>
<li><p><strong>Percentage of homes with no sewer system</strong></p>
<ul>
<li>vph_nodren: Households that have no drainage connected to the public network, septic tank, canyon, crack, river, lake or sea. It includes households for which the characteristics of the house were captured, classified as independent house, apartment in building, housing or room in neighborhood and housing or rooftop room and to which they did not specify housing class</li>
<li>vivpar_hab: Total inhabited homes</li>
</ul>
<p><strong>no_sewing = (vph_nodren) /(vivpar_hab) x 100</strong></p></li>
<li><p><strong>Percentage of homes with no electricity</strong></p>
<ul>
<li>vph_s_elec: Inhabited private homes that do not have electricity. It includes households for which the characteristics of the house were captured, classified as an independent house, apartment in building, housing or room in neighborhood and housing or rooftop room and to which they did not specify housing class.</li>
<li>vivpar_hab: Total inhabited homes</li>
</ul>
<p><strong>no_electricity = (vph_s_elec) /(vivpar_hab) x 100</strong></p></li>
</ul>
</div>
<div id="assets-ownership" class="section level3" number="2.8.4">
<h3><span class="header-section-number">2.8.4</span> Assets Ownership</h3>
<ul>
<li><p><strong>Percentage of Households with no washing machine</strong></p>
<ul>
<li>vph_lavad: Households that have washing machine. It includes households for which the characteristics of the house were captured, classified as an independent house, apartment in building, housing or room in neighborhood and housing or rooftop room and to which they did not specify housing class.</li>
<li>vivpar_hab: Households of any kind: independent house, apartment in building, housing or room in neighborhood, housing or rooftop room, premises not built for room, mobile home, shelters or unspecified class. Includes households without occupant information.</li>
</ul>
<p><strong>no_washingmachine = 1 - (vph_lavad) / (vivpar_hab)</strong></p></li>
<li><p><strong>Percentage of Households with no fridge</strong></p>
<ul>
<li>vph_refri: Households that have a refrigerator. It includes households for which the characteristics of the house were captured, classified as an independent house, apartment in building, housing or room in neighborhood and housing or rooftop room and to which they did not specify housing class.</li>
<li>vivpar_hab: Private dwellings inhabited of any kind: independent house, apartment in building, housing or room in neighborhood, housing or rooftop room, premises not built for room, mobile home, shelters or unspecified class. Includes households without occupant information.</li>
</ul>
<p><strong>no_fridge = 1 - (vph_refri) / vivpar_hab</strong></p></li>
</ul>

</div>
</div>
</div>



            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="twitter.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/worldbank/SDG-big-data/01-introduction.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["big-daa.pdf", "big-daa.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
